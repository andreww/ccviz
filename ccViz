#!/bin/sh

XSLTPROC=/usr/bin/xsltproc
MKTEMP=/usr/bin/mktemp
if [ ! -x $XSLTPROC ]; then
  echo "Error: could not find xsltproc"
  exit 1
elif [ ! -x $MKTEMP ]; then
  echo "Error: could not find mktemp"
  exit 1
elif [ $# -ne 1 ]; then
  echo "Error: need exactly one argument"
  exit 1
fi
TMPXSLTDIR=$(mktemp -d)
trap 'rm -rf $TMPXSLTDIR; exit' 0 1 2 3 15
cat > $TMPXSLTDIR/array.xsl << "EOF"
<!--===================== ARRAY =========================-->

<xsl:stylesheet version="1.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	xmlns:str="http://exslt.org/strings"
        xmlns="http://www.w3.org/1999/xhtml"
        xmlns:cml="http://www.xml-cml.org/schema"
        extension-element-prefixes="str">

  <xsl:template match="cml:array">
    <xsl:variable name="delimiter">
      <xsl:choose>
        <xsl:when test="@delimiter">
          <xsl:value-of select="@delimiter"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="' '"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <p><br/></p>
    <table class="prop2">
      <tr>
        <xsl:for-each select="str:tokenize(text(),$delimiter)">
	  <td>
	    <xsl:choose>
              <xsl:when test="ceiling(.) = floor(.) and not(contains(.,'.'))">
	        <xsl:value-of select="."/>
	      </xsl:when>
	      <xsl:when test="string(number(.)) != 'NaN'">
	        <xsl:value-of select="format-number(., '0.0000')"/>
	      </xsl:when>
	      <xsl:otherwise>
	        <xsl:value-of select="."/>
              </xsl:otherwise>
            </xsl:choose>	        
	  </td>
        </xsl:for-each>
      </tr>
    </table>
  </xsl:template>

</xsl:stylesheet>
EOF
cat > $TMPXSLTDIR/averageVolume.xsl << "EOF"
<?xml version="1.0" encoding="UTF-8" ?>
<xsl:stylesheet version="1.0"
   xmlns:cml="http://www.xml-cml.org/schema"
   xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   xmlns:tohw="http://www.uszla.me.uk/xsl/1.0/functions"
   xmlns:g="http://www.uszla.me.uk/xsl/1.0/graph"
   extension-element-prefixes="tohw"
>

<xsl:import href="graphfuncs.xsl"/>

<xsl:output method="xml"/>

<xsl:param name="fileList"/>

<xsl:template match="/">
  <g:graphSet>
    <g:pointList>
      <xsl:apply-templates select="*"/>
    </g:pointList>
  </g:graphSet>
</xsl:template>

<xsl:template match="file">
  <xsl:element name="point" namespace="http://www.uszla.me.uk/xsl/1.0/graph">
    <xsl:attribute name="x">
      <xsl:value-of select="document(.)//cml:parameterList[@title='control parameters']/cml:parameter[@dictRef='dl_poly:pressure']/cml:scalar"/>
    </xsl:attribute>
    <xsl:attribute name="y">
      <xsl:value-of select="sum(document(.)//cml:step/cml:propertyList[@title='instantaneous']/cml:property[@dictRef='dl_poly:volume']/cml:scalar) div count(document(.)//cml:step/cml:propertyList[@title='instantaneous']/cml:property[@dictRef='dl_poly:volume']/cml:scalar)"/>
    </xsl:attribute>
  </xsl:element>
</xsl:template>


</xsl:stylesheet>

EOF
cat > $TMPXSLTDIR/bandList.xsl << "EOF"
<!--===================== BANDS =========================-->

<xsl:stylesheet version="1.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	xmlns:str="http://exslt.org/strings"
        xmlns="http://www.w3.org/1999/xhtml"
        xmlns:cml="http://www.xml-cml.org/schema"
        extension-element-prefixes="str">
	
<!-- bandList -->
  <xsl:template match="cml:bandList">
    <xsl:if test="title"><H3><xsl:value-of select="@title"/></H3></xsl:if>
<!--    <H3>Eigenvalues</H3>  -->
    <table>
      <xsl:apply-templates select="cml:band"/>
    </table>
  </xsl:template>
  
<!-- band -->
  <xsl:template match="cml:band">
    <xsl:param name="mouseoverString">
      <xsl:for-each select="str:tokenize(@kpoint,' ')">
        <xsl:value-of select="format-number(., '0.000')"/>
      </xsl:for-each>
      <xsl:text> (</xsl:text>
      <xsl:value-of select="format-number(@weight, '0.000')"/>
      <xsl:text>)</xsl:text>
    </xsl:param>

    <tr>
      <th align="left">
	<span>
	  <xsl:attribute name="title">
	    <xsl:value-of select="$mouseoverString"/>
	  </xsl:attribute>
	  <i>k</i>-point
	  <xsl:value-of select="position()"/>
	</span>
      </th>
    </tr>
    <tr>
      <td>
        <table>
	<xsl:for-each select="str:tokenize(normalize-space(.), ' ')">
	  <xsl:if test="(position()-1) mod 10 = 0">
           <xsl:variable name="pos" select="position()"/>
           <tr>
            <td class="eigen"><xsl:value-of select="../token[$pos+0]"/></td>
            <td class="eigen"><xsl:value-of select="../token[$pos+1]"/></td>
            <td class="eigen"><xsl:value-of select="../token[$pos+2]"/></td>
            <td class="eigen"><xsl:value-of select="../token[$pos+3]"/></td>
            <td class="eigen"><xsl:value-of select="../token[$pos+4]"/></td>
            <td class="eigen"><xsl:value-of select="../token[$pos+5]"/></td>
            <td class="eigen"><xsl:value-of select="../token[$pos+6]"/></td>
            <td class="eigen"><xsl:value-of select="../token[$pos+7]"/></td>
            <td class="eigen"><xsl:value-of select="../token[$pos+8]"/></td>
            <td class="eigen"><xsl:value-of select="../token[$pos+9]"/></td>
          </tr>
         </xsl:if>
	</xsl:for-each>
        </table>
      </td>
    </tr>
  </xsl:template>

</xsl:stylesheet>
EOF
cat > $TMPXSLTDIR/ccViz.xsl << "EOF"
<?xml version="1.0" encoding="UTF-8" ?>

<xsl:stylesheet version="1.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        xmlns:cml="http://www.xml-cml.org/schema"
        xmlns="http://www.w3.org/1999/xhtml"
        exclude-result-prefixes="xsl"
        >

<!-- CML -->
<xsl:import href="structure.xsl"/>
<xsl:import href="dictionary.xsl"/>
<xsl:import href="metadata.xsl"/>
<xsl:import href="parameter.xsl"/>
<xsl:import href="property.xsl"/>
<xsl:import href="bandList.xsl"/>
<xsl:import href="formula.xsl"/>
<xsl:import href="units.xsl"/>

<!-- CMLComp -->
<xsl:import href="module.xsl"/>
<xsl:import href="lattice.xsl"/>

<!-- STMML -->
<xsl:import href="scalar.xsl"/>
<xsl:import href="array.xsl"/> 
<xsl:import href="matrix.xsl"/>
<xsl:import href="table.xsl"/>

<!-- Dictionary -->
<xsl:import href="dict2frag.xsl"/>
<xsl:import href="dictcommon.xsl"/>

<!-- Special templates -->
<xsl:import href="summary.xsl"/>
<xsl:import href="rdf.xsl"/>

<xsl:strip-space elements="*"/>

<xsl:template match="text()"/>

<!-- Global Variable holding the program name -->
<xsl:param name="prog">
  <xsl:choose>
    <xsl:when test="/cml:cml/cml:metadataList/cml:metadata[@name='siesta:Program']">
     <xsl:value-of select="/cml:cml/cml:metadataList/cml:metadata[@name='siesta:Program']/@content"/>
    </xsl:when>
    <xsl:when test="/cml:cml/cml:metadataList/cml:metadata[@name='dl_poly:Program']">
     <xsl:value-of select="/cml:cml/cml:metadataList/cml:metadata[@name='dl_poly:Program']/@content"/>
    </xsl:when>
    <!-- <xsl:when test="/cml:cml/cml:metadataList/cml:metadata[@name='dc:creator']">
    <xsl:message> Three </xsl:message>
     <xsl:value-of select="/cml:cml/cml:metadata[@name='dc:creator']/@content"/>
    </xsl:when> -->
    <xsl:when test="/cml:cml/cml:metadataList/cml:metadata[@name='dc:identifier']/@content = 'DL_POLY version 3.06 / March 2006'">
      <xsl:text>DL_POLY</xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:text>Program</xsl:text>
    </xsl:otherwise>
  </xsl:choose>
</xsl:param>

<!-- Global variable - do we want jmol output or not? -->
  <xsl:param name="Jmol">
    <xsl:value-of select="boolean(//cml:molecule)"/>
  </xsl:param>

<!-- Global variable - how many steps do we want? -->
  <xsl:param name="stepinterval">
    <xsl:choose>
      <xsl:when test="count(cml:cml/cml:module[@role='step']) &gt; 100">
         10
      </xsl:when>
      <xsl:otherwise>
         1
      </xsl:otherwise>
    </xsl:choose>
  </xsl:param>


  <xsl:output method="xml" version="1.0" encoding="UTF-8" 
    omit-xml-declaration="no" standalone="yes"
    doctype-public="-//W3C//DTD XHTML 1.0 Strict//EN"
    doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
    indent="yes" media-type="application/xhtml+xml"/>


<!-- MAIN TEMPLATE -->
  <xsl:template match="/">
    <html>
      <head>
	<title>
	  <xsl:value-of select="$prog"/>
	  <xsl:text> Output</xsl:text>
	</title>
        <style type="text/css">
          <xsl:call-template name="css-style"/>
        </style>
        <xsl:if test="$Jmol!='false'">
          <script type="text/javascript" src="http://www.eminerals.org/jmol/JmolX.js"/>
        </xsl:if>

        <script type="text/javascript">
          <xsl:call-template name="mainJavascript"/>
        </script>
      </head>

      <body>
        <xsl:if test="$Jmol!='false'">
         <xsl:attribute name="onload">
           <xsl:text>jmolXInitialize(&quot;http://www.eminerals.org/jmol&quot;)</xsl:text>
         </xsl:attribute>
        </xsl:if>
 
        <div id="head"><div class="bigTitle">
           <xsl:value-of select="$prog"/>
           <xsl:text> Output</xsl:text>
        </div></div>

<!-- Generate body of document -->
        <div id="maindisplay">
          <div class="innerMain">

            <br/><div onclick="js:togglemenu(&quot;initialMetadata&quot;)" class="divisionTitle clickableDiv">
              <xsl:value-of select="'Initial Metadata'"/>
            </div>
            <div class="sublevel" id="initialMetadata">
              <xsl:apply-templates select="/cml:cml/cml:metadataList[position()=1]"/>
            </div><br/>

            <br/><div onclick="js:togglemenu(&quot;inputParams&quot;)" class="divisionTitle clickableDiv">
              <xsl:value-of select="'Input Parameters'"/>
            </div>
            <div class="sublevel" id="inputParams">
              <xsl:apply-templates select="/cml:cml/cml:parameterList"/>
            <!--   <xsl:apply-templates select="/cml:cml/cml:parameterList[position()=1]"/> -->
            </div><br/>

            <br/><div onclick="js:togglemenu(&quot;initialState&quot;)" class="divisionTitle clickableDiv">
              <xsl:value-of select="'Input State of System'"/>
            </div>
            <div class="sublevel" id="initialState">
              <xsl:apply-templates select="/cml:cml/cml:module[@title='Initial System']" mode="noTitle"/>
            </div><br/>

            <br/><div onclick="js:togglemenu(&quot;mainBody&quot;)" class="divisionTitle clickableDiv">
              <xsl:value-of select="'Main Body of Simulation'"/>
            </div>
            <div class="sublevel" id="mainBody">
              <xsl:apply-templates select="/cml:cml/cml:module[(@title!='Initial System' and @title!='Finalization') or not(@title)]"/>
            </div><br/>

            <br/><div onclick="js:togglemenu(&quot;finalState&quot;)" class="divisionTitle clickableDiv">
              <xsl:value-of select="'Final State of System'"/>
            </div>
            <div class="sublevel" id="finalState">
              <xsl:apply-templates select="/cml:cml/cml:module[@title='Finalization']" mode="noTitle"/>
            </div><br/>

            <br/>
            <div onclick="js:togglemenu(&quot;summaryInfo&quot;)" class="divisionTitle clickableDiv">
              <xsl:text>Summary Information</xsl:text>
            </div>
            <div class="sublevel" id="summaryInfo">
              <xsl:call-template name="summary"/>
	    </div>
            <br/>
            <hr/>
          </div>
        </div>

<!-- Generate dictionary of document -->
        <div id="dictdisplay">
          <div class="innerDict">
            <xsl:call-template name="addDict"/>
          </div>
        </div>
<!-- -->

        <div id="foot">
          <i>Created by Toby White, Jon Wakelin,  &amp; Richard Bruin </i>
        </div>

      </body>
    </html>

  </xsl:template>

  <xsl:template name="top.level.section">
    <xsl:param name="uid"/>
    <xsl:param name="title"/>
    <xsl:param name="templates"/>
  </xsl:template>

  <xsl:template name="css-style">
    <xsl:text>
      <![CDATA[
        html       {
                     height:100%;
                     max-height:100%;
                     padding:0;
                     margin:0;
                     border:0;
                     background:#fff;
                     overflow: hidden;
                   }
        body       {
                     font-family: serif;
                     background: #ffffff;
                     height:100%;
                     max-height:100%;
                     overflow:hidden;
                     padding:0;
                     margin:0;
                     border:0;
                   }
        table      { text-align: center; 
		     border-collapse: collapse; 
		     }
	table.prop { 
	  	     text-align: right; 
	             border-collapse: collapse; 
	             border-left: hidden; 
		     border-right: hidden;
		     border-top: 1px solid Gray; 
		     border-bottom: 1px solid Gray; 
		     }
        table.structure { background: #ffffff; }

        .step       { 
                      border: 1px solid Gray;
                    }
        th.step     {
                      background: #aa2222;
                    }
        td.step     {
                      font-family: monospace;
                      background: #cc9999;
                    }
        td.stepnum { background: #ffffff; ; }

        .coords { border: 1px solid Gray;}

	.graph     {
                     text-align: left;
                   }
	
	th        { font-weight: bold; }
	td        { padding-left: 7px; padding-right: 7px;}
	.bigTitle 
                  {
                    color: #ffffff; 
                    background: Navy;    
                    font-weight: bold; 
                    margin: 0px; 
                    padding: 2px;
                    font-size: xx-large;
                  }
	.divisionTitle {
                  }
        .listTitle
                  {
                    font-weight: 900;
                    font-size: x-large;
                    margin-top: 2.5ex;
                    margin-bottom: 2.5ex;
                  }
	.clickable { 
                    text-decoration: underline;
                    color: #ffffff; 
                    background: #4682B4; 
                    cursor: pointer; 
                   }
	.eigen    { text-align: right; padding-left: 7px; padding-right: 7px; }
	.band     { vertical-align: text-top; }
	.toplevel { display: block; font-weight: 400; margin-bottom: 0; }
        .clickableDiv {color: #ffffff;
                    background: #4682B4;
                    font-weight: bold;
                    font-size: x-large;
                    border-top-width: 0px;
                    border-left-width: 0px;
                    border-right-width: 5px;
                    border-bottom-width: 5px;
                    border-color: #7dB7FF;
                    border-style: solid;
                    }
        .clickableDiv:hover {
                    color: #9999ff; 
                    }
        .moduletitle {
                    padding: 5px;
                    margin-top: 10px;
                    margin-bottom: 10px;
                     }
        .steptitle   {
                    padding: 5px;
                    margin-top: 10px;
                    margin-bottom: 10px;
                     }
        .switch      { color: #ffffff;
                       background: #4682B4;
                       font-weight: bold;
                       cursor: pointer;
                       display: inline;
                       font-size: medium; }
	.sublevel { display: none; font-weight: normal; margin-left: 20px; margin-top: 0; line-height: 14px; }
        .paramname {color: #0000ff; }
        .paramvalue {color: #ff0000; }
        #head        {
                       position:absolute; margin:0; top:0; left:0; display:block; width:100%; height:50px; z-index:5; color:#fff; background: Navy;
                     }
        #foot        {
                       position:absolute; margin:0; bottom:0; left:0; display:block; width:100%; height:25px; background:rgb(233,238,242); font-size:0.8em; z-index:5; text-align:right; color:rgb(157,78,84);
                     }
        #maindisplay {
                       position:absolute;
                       left:0;
                       top:50px;
                       bottom:25px;
                       z-index: 4;
                       width:80%;
                       overflow:auto;
                     }
        #dictdisplay {
                       position:absolute;
                       left:80%;
                       top:50px;
                       bottom:25px;
                       z-index: 4;
                       width:20%;
                       overflow:auto;
                     }
        * html #maindisplay, * html #dictdisplay {
                       height:100%;
                       top:0;
                       bottom:0;
                       border-top:50px solid #fff;
                       border-bottom:25px solid #fff;}
        .innerMain  {
                       display:block;
                       padding:0 10px 10px 10px;
                    }
        .innerDict {
                       display:block;
                       padding:0 10px 10px 10px;
                       padding-bottom:300%;
                    }

        .dictEntry  { 
                       font-family: sans-serif;
                       font-weight: bold;
                       font-size: medium;
                    }
        .dictDefinition { 
                       font-family: serif;
                       font-weight: normal;
                       font-size: small; 
                         }
        .dictDescription { 
                       font-family: serif;
                       font-weight: normal;
                       font-size: small; 
                       font-style: italic;
                         }

      ]]>
    </xsl:text>
  </xsl:template>

  <xsl:template name="mainJavascript">
    <xsl:text>
      //<![CDATA[
      function togglemenu(submenu) { 
        if (document.getElementById(submenu).style.display == "none") {
          document.getElementById(submenu).style.display = "block";
        }
        else {
          document.getElementById(submenu).style.display = "none";
         }
      }

      function toggleButton(button, submenu) { 
        if (document.getElementById(submenu).style.display == "none") {
          document.getElementById(submenu).style.display = "block";
          button.setAttribute('value', 'Hide');
        }
        else {
          document.getElementById(submenu).style.display = "none";
          button.setAttribute('value', 'Show');
         }
      }

      function toggleJmol(sz, inputNode, thisId, parentId) {
        // Grab object node to be created.
        var appNode = document.getElementById(parentId);

        if (appNode.hasChildNodes()) {
          var newAppNode = document.createElementNS('http://www.w3.org/1999/xhtml','object');
          newAppNode.setAttribute('style', "display:none;")
          newAppNode.setAttribute('id', parentId);
          var newMessage = 'Activate Jmol viewer';
        }
        else {
          var newAppNode = jmolXAppletNodeId(sz, thisId, "background white", nameSuffix=thisId);
          newAppNode.setAttribute('id', parentId);
          var newMessage = 'Deactivate Jmol viewer';
        }
        appNode.parentNode.replaceChild(newAppNode, appNode);
        inputNode.setAttribute('value', newMessage);
      }

      //]]>
    </xsl:text>
  </xsl:template>

</xsl:stylesheet>
EOF
cat > $TMPXSLTDIR/chunker.xsl << "EOF"
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:saxon="http://icl.com/saxon"
                xmlns:lxslt="http://xml.apache.org/xslt"
                xmlns:xalanredirect="org.apache.xalan.xslt.extensions.Redirect"
                xmlns:exsl="http://exslt.org/common"
                xmlns:doc="http://nwalsh.com/xsl/documentation/1.0"
		version="1.1"
                exclude-result-prefixes="doc"
                extension-element-prefixes="saxon xalanredirect lxslt exsl">

<!-- ********************************************************************
     $Id: chunker.xsl,v 1.24 2003/11/30 19:42:23 bobstayton Exp $
     ********************************************************************

     This file is part of the XSL DocBook Stylesheet distribution.
     See ../README or http://nwalsh.com/docbook/xsl/ for copyright
     and other information.

...  The following copyright information is extracted from the DocBook
     distribution, and applies to this file ...

Copyright
_________

Copyright (C) 1999, 2000, 2001, 2002 Norman Walsh

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the ``Software''), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

Except as contained in this notice, the names of individuals
credited with contribution to this software shall not be used in
advertising or otherwise to promote the sale, use or other
dealings in this Software without prior written authorization
from the individuals in question.

Any stylesheet derived from this Software that is publically
distributed will be identified with a different name and the
version strings in any derived Software will be changed so that
no possibility of confusion between the derived package and this
Software will exist.

Warranty
________

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT.  IN NO EVENT SHALL NORMAN WALSH OR ANY OTHER
CONTRIBUTOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Contacting the Author
_____________________

These stylesheets are maintained by Norman Walsh, <ndw@nwalsh.com>.

     ******************************************************************** -->

<!-- ==================================================================== -->

<!-- This stylesheet works with XSLT implementations that support -->
<!-- exsl:document, saxon:output, or xalanredirect:write -->
<!-- Note: Only Saxon 6.4.2 or later is supported. -->

<xsl:param name="chunker.output.method" select="'html'"/>
<xsl:param name="chunker.output.encoding" select="'ISO-8859-1'"/>
<xsl:param name="chunker.output.indent" select="'no'"/>
<xsl:param name="chunker.output.omit-xml-declaration" select="'no'"/>
<xsl:param name="chunker.output.standalone" select="'no'"/>
<xsl:param name="chunker.output.doctype-public" select="''"/>
<xsl:param name="chunker.output.doctype-system" select="''"/>
<xsl:param name="chunker.output.media-type" select="''"/>
<xsl:param name="chunker.output.cdata-section-elements" select="''"/>

<xsl:param name="saxon.character.representation" select="'entity;decimal'"/>

<!-- ==================================================================== -->

<xsl:template name="make-relative-filename">
  <xsl:param name="base.dir" select="'./'"/>
  <xsl:param name="base.name" select="''"/>

  <xsl:choose>
    <!-- put Saxon first to work around a bug in libxslt -->
    <xsl:when test="element-available('saxon:output')">
      <!-- Saxon doesn't make the chunks relative -->
      <xsl:value-of select="concat($base.dir,$base.name)"/>
    </xsl:when>
    <xsl:when test="element-available('exsl:document')">
      <!-- EXSL document does make the chunks relative, I think -->
      <xsl:choose>
        <xsl:when test="count(parent::*) = 0">
          <xsl:value-of select="concat($base.dir,$base.name)"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="$base.name"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>
    <xsl:when test="element-available('xalanredirect:write')">
      <!-- Xalan doesn't make the chunks relative -->
      <xsl:value-of select="concat($base.dir,$base.name)"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:message terminate="yes">
        <xsl:text>Don't know how to chunk with </xsl:text>
        <xsl:value-of select="system-property('xsl:vendor')"/>
      </xsl:message>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template name="write.chunk">
  <xsl:param name="filename" select="''"/>
  <xsl:param name="quiet" select="0"/>

  <xsl:param name="method" select="$chunker.output.method"/>
  <xsl:param name="encoding" select="$chunker.output.encoding"/>
  <xsl:param name="indent" select="$chunker.output.indent"/>
  <xsl:param name="omit-xml-declaration"
             select="$chunker.output.omit-xml-declaration"/>
  <xsl:param name="standalone" select="$chunker.output.standalone"/>
  <xsl:param name="doctype-public" select="$chunker.output.doctype-public"/>
  <xsl:param name="doctype-system" select="$chunker.output.doctype-system"/>
  <xsl:param name="media-type" select="$chunker.output.media-type"/>
  <xsl:param name="cdata-section-elements"
             select="$chunker.output.cdata-section-elements"/>

  <xsl:param name="content"/>

  <xsl:if test="$quiet = 0">
    <xsl:message>
      <xsl:text>Writing </xsl:text>
      <xsl:value-of select="$filename"/>
      <xsl:if test="name(.) != ''">
        <xsl:text> for </xsl:text>
        <xsl:value-of select="name(.)"/>
        <xsl:if test="@id">
          <xsl:text>(</xsl:text>
          <xsl:value-of select="@id"/>
          <xsl:text>)</xsl:text>
        </xsl:if>
      </xsl:if>
    </xsl:message>
  </xsl:if>

  <xsl:choose>
    <xsl:when test="element-available('exsl:document')">
      <xsl:choose>
        <!-- Handle the permutations ... -->
        <xsl:when test="$media-type != ''">
          <xsl:choose>
            <xsl:when test="$doctype-public != '' and $doctype-system != ''">
              <exsl:document href="{$filename}"
                             method="{$method}"
                             encoding="{$encoding}"
                             indent="{$indent}"
                             omit-xml-declaration="{$omit-xml-declaration}"
                             cdata-section-elements="{$cdata-section-elements}"
                             media-type="{$media-type}"
                             doctype-public="{$doctype-public}"
                             doctype-system="{$doctype-system}"
                             standalone="{$standalone}">
                <xsl:copy-of select="$content"/>
              </exsl:document>
            </xsl:when>
            <xsl:when test="$doctype-public != '' and $doctype-system = ''">
              <exsl:document href="{$filename}"
                             method="{$method}"
                             encoding="{$encoding}"
                             indent="{$indent}"
                             omit-xml-declaration="{$omit-xml-declaration}"
                             cdata-section-elements="{$cdata-section-elements}"
                             media-type="{$media-type}"
                             doctype-public="{$doctype-public}"
                             standalone="{$standalone}">
                <xsl:copy-of select="$content"/>
              </exsl:document>
            </xsl:when>
            <xsl:when test="$doctype-public = '' and $doctype-system != ''">
              <exsl:document href="{$filename}"
                             method="{$method}"
                             encoding="{$encoding}"
                             indent="{$indent}"
                             omit-xml-declaration="{$omit-xml-declaration}"
                             cdata-section-elements="{$cdata-section-elements}"
                             media-type="{$media-type}"
                             doctype-system="{$doctype-system}"
                             standalone="{$standalone}">
                <xsl:copy-of select="$content"/>
              </exsl:document>
            </xsl:when>
            <xsl:otherwise><!-- $doctype-public = '' and $doctype-system = ''"> -->
              <exsl:document href="{$filename}"
                             method="{$method}"
                             encoding="{$encoding}"
                             indent="{$indent}"
                             omit-xml-declaration="{$omit-xml-declaration}"
                             cdata-section-elements="{$cdata-section-elements}"
                             media-type="{$media-type}"
                             standalone="{$standalone}">
                <xsl:copy-of select="$content"/>
              </exsl:document>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:when>
        <xsl:otherwise>
          <xsl:choose>
            <xsl:when test="$doctype-public != '' and $doctype-system != ''">
              <exsl:document href="{$filename}"
                             method="{$method}"
                             encoding="{$encoding}"
                             indent="{$indent}"
                             omit-xml-declaration="{$omit-xml-declaration}"
                             cdata-section-elements="{$cdata-section-elements}"
                             doctype-public="{$doctype-public}"
                             doctype-system="{$doctype-system}"
                             standalone="{$standalone}">
                <xsl:copy-of select="$content"/>
              </exsl:document>
            </xsl:when>
            <xsl:when test="$doctype-public != '' and $doctype-system = ''">
              <exsl:document href="{$filename}"
                             method="{$method}"
                             encoding="{$encoding}"
                             indent="{$indent}"
                             omit-xml-declaration="{$omit-xml-declaration}"
                             cdata-section-elements="{$cdata-section-elements}"
                             doctype-public="{$doctype-public}"
                             standalone="{$standalone}">
                <xsl:copy-of select="$content"/>
              </exsl:document>
            </xsl:when>
            <xsl:when test="$doctype-public = '' and $doctype-system != ''">
              <exsl:document href="{$filename}"
                             method="{$method}"
                             encoding="{$encoding}"
                             indent="{$indent}"
                             omit-xml-declaration="{$omit-xml-declaration}"
                             cdata-section-elements="{$cdata-section-elements}"
                             doctype-system="{$doctype-system}"
                             standalone="{$standalone}">
                <xsl:copy-of select="$content"/>
              </exsl:document>
            </xsl:when>
            <xsl:otherwise><!-- $doctype-public = '' and $doctype-system = ''"> -->
             <xsl:text> writing some more </xsl:text>
              <exsl:document href="{$filename}"
                             method="{$method}"
                             encoding="{$encoding}"
                             indent="{$indent}"
                             omit-xml-declaration="{$omit-xml-declaration}"
                             cdata-section-elements="{$cdata-section-elements}"
                             standalone="{$standalone}">
                <xsl:copy-of select="$content"/>
              </exsl:document>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>

    <xsl:when test="element-available('saxon:output')">
      <xsl:choose>
        <!-- Handle the permutations ... -->
        <xsl:when test="$media-type != ''">
          <xsl:choose>
            <xsl:when test="$doctype-public != '' and $doctype-system != ''">
              <saxon:output saxon:character-representation="{$saxon.character.representation}"
                            href="{$filename}"
                            method="{$method}"
                            encoding="{$encoding}"
                            indent="{$indent}"
                            omit-xml-declaration="{$omit-xml-declaration}"
                            cdata-section-elements="{$cdata-section-elements}"
                            media-type="{$media-type}"
                            doctype-public="{$doctype-public}"
                            doctype-system="{$doctype-system}"
                            standalone="{$standalone}">
                <xsl:copy-of select="$content"/>
              </saxon:output>
            </xsl:when>
            <xsl:when test="$doctype-public != '' and $doctype-system = ''">
              <saxon:output saxon:character-representation="{$saxon.character.representation}"
                            href="{$filename}"
                            method="{$method}"
                            encoding="{$encoding}"
                            indent="{$indent}"
                            omit-xml-declaration="{$omit-xml-declaration}"
                            cdata-section-elements="{$cdata-section-elements}"
                            media-type="{$media-type}"
                            doctype-public="{$doctype-public}"
                            standalone="{$standalone}">
                <xsl:copy-of select="$content"/>
              </saxon:output>
            </xsl:when>
            <xsl:when test="$doctype-public = '' and $doctype-system != ''">
              <saxon:output saxon:character-representation="{$saxon.character.representation}"
                            href="{$filename}"
                            method="{$method}"
                            encoding="{$encoding}"
                            indent="{$indent}"
                            omit-xml-declaration="{$omit-xml-declaration}"
                            cdata-section-elements="{$cdata-section-elements}"
                            media-type="{$media-type}"
                            doctype-system="{$doctype-system}"
                            standalone="{$standalone}">
                <xsl:copy-of select="$content"/>
              </saxon:output>
            </xsl:when>
            <xsl:otherwise><!-- $doctype-public = '' and $doctype-system = ''"> -->
              <saxon:output saxon:character-representation="{$saxon.character.representation}"
                            href="{$filename}"
                            method="{$method}"
                            encoding="{$encoding}"
                            indent="{$indent}"
                            omit-xml-declaration="{$omit-xml-declaration}"
                            cdata-section-elements="{$cdata-section-elements}"
                            media-type="{$media-type}"
                            standalone="{$standalone}">
                <xsl:copy-of select="$content"/>
              </saxon:output>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:when>
        <xsl:otherwise>
          <xsl:choose>
            <xsl:when test="$doctype-public != '' and $doctype-system != ''">
              <saxon:output saxon:character-representation="{$saxon.character.representation}"
                            href="{$filename}"
                            method="{$method}"
                            encoding="{$encoding}"
                            indent="{$indent}"
                            omit-xml-declaration="{$omit-xml-declaration}"
                            cdata-section-elements="{$cdata-section-elements}"
                            doctype-public="{$doctype-public}"
                            doctype-system="{$doctype-system}"
                            standalone="{$standalone}">
                <xsl:copy-of select="$content"/>
              </saxon:output>
            </xsl:when>
            <xsl:when test="$doctype-public != '' and $doctype-system = ''">
              <saxon:output saxon:character-representation="{$saxon.character.representation}"
                            href="{$filename}"
                            method="{$method}"
                            encoding="{$encoding}"
                            indent="{$indent}"
                            omit-xml-declaration="{$omit-xml-declaration}"
                            cdata-section-elements="{$cdata-section-elements}"
                            doctype-public="{$doctype-public}"
                            standalone="{$standalone}">
                <xsl:copy-of select="$content"/>
              </saxon:output>
            </xsl:when>
            <xsl:when test="$doctype-public = '' and $doctype-system != ''">
              <saxon:output saxon:character-representation="{$saxon.character.representation}"
                            href="{$filename}"
                            method="{$method}"
                            encoding="{$encoding}"
                            indent="{$indent}"
                            omit-xml-declaration="{$omit-xml-declaration}"
                            cdata-section-elements="{$cdata-section-elements}"
                            doctype-system="{$doctype-system}"
                            standalone="{$standalone}">
                <xsl:copy-of select="$content"/>
              </saxon:output>
            </xsl:when>
            <xsl:otherwise><!-- $doctype-public = '' and $doctype-system = ''"> -->
              <saxon:output saxon:character-representation="{$saxon.character.representation}"
                            href="{$filename}"
                            method="{$method}"
                            encoding="{$encoding}"
                            indent="{$indent}"
                            omit-xml-declaration="{$omit-xml-declaration}"
                            cdata-section-elements="{$cdata-section-elements}"
                            standalone="{$standalone}">
                <xsl:copy-of select="$content"/>
              </saxon:output>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>

    <xsl:when test="element-available('xalanredirect:write')">
      <!-- Xalan uses xalanredirect -->
      <xalanredirect:write file="{$filename}">
        <xsl:copy-of select="$content"/>
      </xalanredirect:write>
    </xsl:when>

    <xsl:otherwise>
      <!-- it doesn't matter since we won't be making chunks... -->
      <xsl:message terminate="yes">
        <xsl:text>Can't make chunks with </xsl:text>
        <xsl:value-of select="system-property('xsl:vendor')"/>
        <xsl:text>'s processor.</xsl:text>
      </xsl:message>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template name="write.chunk.with.doctype">
  <xsl:param name="filename" select="''"/>
  <xsl:param name="quiet" select="0"/>

  <xsl:param name="method" select="$chunker.output.method"/>
  <xsl:param name="encoding" select="$chunker.output.encoding"/>
  <xsl:param name="indent" select="$chunker.output.indent"/>
  <xsl:param name="omit-xml-declaration"
             select="$chunker.output.omit-xml-declaration"/>
  <xsl:param name="standalone" select="$chunker.output.standalone"/>
  <xsl:param name="doctype-public" select="$chunker.output.doctype-public"/>
  <xsl:param name="doctype-system" select="$chunker.output.doctype-system"/>
  <xsl:param name="media-type" select="$chunker.output.media-type"/>
  <xsl:param name="cdata-section-elements"
             select="$chunker.output.cdata-section-elements"/>

  <xsl:param name="content"/>

  <xsl:call-template name="write.chunk">
    <xsl:with-param name="filename" select="$filename"/>
    <xsl:with-param name="quiet" select="$quiet"/>
    <xsl:with-param name="method" select="$method"/>
    <xsl:with-param name="encoding" select="$encoding"/>
    <xsl:with-param name="indent" select="$indent"/>
    <xsl:with-param name="omit-xml-declaration" select="$omit-xml-declaration"/>
    <xsl:with-param name="standalone" select="$standalone"/>
    <xsl:with-param name="doctype-public" select="$doctype-public"/>
    <xsl:with-param name="doctype-system" select="$doctype-system"/>
    <xsl:with-param name="media-type" select="$media-type"/>
    <xsl:with-param name="cdata-section-elements" select="$cdata-section-elements"/>
    <xsl:with-param name="content" select="$content"/>
  </xsl:call-template>
</xsl:template>

<xsl:template name="write.text.chunk">
  <xsl:param name="filename" select="''"/>
  <xsl:param name="quiet" select="0"/>
  <xsl:param name="method" select="'text'"/>
  <xsl:param name="encoding" select="$chunker.output.encoding"/>
  <xsl:param name="media-type" select="$chunker.output.media-type"/>
  <xsl:param name="content"/>

  <xsl:call-template name="write.chunk">
    <xsl:with-param name="filename" select="$filename"/>
    <xsl:with-param name="quiet" select="$quiet"/>
    <xsl:with-param name="method" select="$method"/>
    <xsl:with-param name="encoding" select="$encoding"/>
    <xsl:with-param name="indent" select="'no'"/>
    <xsl:with-param name="omit-xml-declaration" select="'no'"/>
    <xsl:with-param name="standalone" select="'no'"/>
    <xsl:with-param name="doctype-public"/>
    <xsl:with-param name="doctype-system"/>
    <xsl:with-param name="media-type" select="$media-type"/>
    <xsl:with-param name="cdata-section-elements"/>
    <xsl:with-param name="content" select="$content"/>
  </xsl:call-template>
</xsl:template>


</xsl:stylesheet>
EOF
cat > $TMPXSLTDIR/data.xsl << "EOF"
<xsl:stylesheet
        xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	xmlns:svg="http://www.w3.org/2000/svg"
        xmlns="http://www.w3.org/1999/xhtml"
        xmlns:cml="http://www.xml-cml.org/schema"
        version="1.0">

  <xsl:import href="dictionary.xsl"/>

  <xsl:output method="xml" indent="yes" name="graph"/>
  <xsl:output method="html" indent="yes" name="graphWrapper"/>


  <xsl:template match='/'>

    <!-- Draw a graph of E_KS -->

    <xsl:param name="graphProperty">siesta:E_KS</xsl:param>
    <xsl:param name="graphType">step</xsl:param>
    <xsl:variable name="fileName" select="'graph_E_KS'"/>

    <xsl:apply-templates select="cml/step">
      <xsl:with-param name="graphProperty">
	<xsl:value-of select="$graphProperty"/>
      </xsl:with-param>
      <xsl:with-param name="graphType">
	<xsl:value-of select="$graphType"/>
      </xsl:with-param>
      <xsl:with-param name="outputFile">
	<xsl:value-of select="concat($fileName, '.svg')"/>
      </xsl:with-param>
    </xsl:apply-templates>
    
    <xsl:result-document format="graphWrapper" href="{concat($fileName, '.html')}">

      <HTML>
        <HEAD>
	  <TITLE>Graph <xsl:value-of select="$graphProperty"/></TITLE>
	</HEAD>
	<BODY BGCOLOR="white">
	  <EMBED ALIGN="left" WIDTH="600" HEIGHT="600">
	    <xsl:attribute name="src">
	      <xsl:value-of select="concat($fileName, '.svg')"/>
	    </xsl:attribute>
	  </EMBED>
	</BODY>
      </HTML>
    </xsl:result-document>

    <!-- Draw a graph of Etot per step -->
<!--
    <xsl:param name="graphProperty">siesta:Etot</xsl:param>
    <xsl:param name="graphType">scfStep</xsl:param>

    <xsl:for-each select="cml/step">

      <xsl:variable name="fileName">
	<xsl:value-of select="concat('graph_', position())"/>
      </xsl:variable>

      <xsl:apply-templates select=".">
        <xsl:with-param name="graphProperty">
	  <xsl:value-of select="$graphProperty"/>
        </xsl:with-param>
        <xsl:with-param name="graphType">
	  <xsl:value-of select="$graphType"/>
        </xsl:with-param>
        <xsl:with-param name="outputFile">
	  <xsl:value-of select="concat($fileName, '.svg')"/>
        </xsl:with-param>
        <xsl:with-param name="position">
	  <xsl:value-of select="position()"/>
        </xsl:with-param>
      </xsl:apply-templates>


      <xsl:result-document format="graphWrapper" href="{concat($fileName, '.html')}">

        <HTML>
	  <HEAD>
	    <TITLE>Graph <xsl:value-of select="$graphProperty"/></TITLE>
	  </HEAD>
	  <BODY BGCOLOR="white">
	    <EMBED ALIGN="left" WIDTH="800" HEIGHT="800">
	      <xsl:attribute name="src">
	        <xsl:value-of select="concat($fileName, '.svg')"/>
	      </xsl:attribute>
	    </EMBED>
	  </BODY>
	</HTML>

      </xsl:result-document>

    </xsl:for-each>
-->
  </xsl:template>



  <xsl:template match="step">
    <xsl:param name="graphProperty"/>
    <xsl:param name="graphType"/>
    <xsl:param name="outputFile"/>
    <xsl:param name="position" select="1"/>

    <!-- Chart dimensions -->
    <xsl:param name='chartX' select='350'/>
    <xsl:param name='chartY' select='250'/>
    
    <!-- Max and Min data values -->
    <xsl:param name="maxX">
      <xsl:choose>
 	<xsl:when test="$graphType='step'">
	  <xsl:value-of select="count(//cml/step)"/>
	</xsl:when>
	<xsl:when test="$graphType='scfStep'">
	  <xsl:for-each select="//cml/step">
	    <xsl:if test="position() = $position">
	      <xsl:value-of select="count(step)"/>
	    </xsl:if>
	  </xsl:for-each>
	</xsl:when>
      </xsl:choose>
    </xsl:param>
    <xsl:param name="minX" select="1"/>

    <xsl:param name="maxY">
      <xsl:choose>
	<xsl:when test="$graphType='step'">
	  <xsl:for-each select="//cml/step/propertyList/property[@dictRef = $graphProperty]">
            <xsl:sort data-type="number" select="scalar" order="ascending"/>
            <xsl:if test="position() = last()">
              <xsl:value-of select="scalar"/>
            </xsl:if>
          </xsl:for-each>
	</xsl:when>
	<xsl:when test="$graphType='scfStep'">
	  <xsl:for-each select="//cml/step">
	    <xsl:if test="position() = $position">
	      <xsl:for-each select="step/propertyList/property[@dictRef = $graphProperty]">
                <xsl:sort data-type="number" select="scalar" order="ascending"/>
                <xsl:if test="position() = last()">
                  <xsl:value-of select="scalar"/>
                </xsl:if>
	      </xsl:for-each>
	    </xsl:if>
	  </xsl:for-each>
	</xsl:when>
      </xsl:choose>
    </xsl:param>

    <xsl:param name="minY">
      <xsl:choose>
	<xsl:when test="$graphType='step'">
	  <xsl:for-each select="//cml/step/propertyList/property[@dictRef = $graphProperty]">
            <xsl:sort data-type="number" select="scalar" order="descending"/>
            <xsl:if test="position() = last()">
              <xsl:value-of select="scalar"/>
            </xsl:if>
          </xsl:for-each>
	</xsl:when>
	<xsl:when test="$graphType='scfStep'">
	  <xsl:for-each select="//cml/step">
	    <xsl:if test="position() = $position">
	      <xsl:for-each select="step/propertyList/property[@dictRef = $graphProperty]">
                <xsl:sort data-type="number" select="scalar" order="descending"/>
                <xsl:if test="position() = last()">
                  <xsl:value-of select="scalar"/>
                </xsl:if>
	      </xsl:for-each>
	    </xsl:if>
	  </xsl:for-each>
	</xsl:when>
      </xsl:choose>
    </xsl:param>


    <!-- Max and Min Range values -->

    <!-- Data ranges -->
    <xsl:param name="rangeX" select="$maxX - $minX"/>

    <xsl:param name="rangeY" select="$maxY - $minY"/>

    <!-- Rounded Data Ranges -->    
    <xsl:param name="ceilingX">
      <xsl:choose>
	<xsl:when test="ceiling(($maxX + ($rangeX div 10)) &gt; 0) and ($maxX &lt;= 0)">
	  <xsl:value-of select="0"/>
	</xsl:when>
	<xsl:otherwise>
          <xsl:value-of select="ceiling($maxX + ($rangeX div 10))"/>
	</xsl:otherwise>
      </xsl:choose>
    </xsl:param>

    <xsl:param name="floorX">
      <xsl:choose>
	<xsl:when test="floor(($minX - ($rangeX div 10)) &lt; 0) and ($minX &gt;= 0)">
  	  <xsl:value-of select="0"/>
        </xsl:when>
	<xsl:otherwise>
          <xsl:value-of select="floor($minX - ($rangeX div 10))"/>
	</xsl:otherwise>
      </xsl:choose>
    </xsl:param>
    
    <xsl:param name="floorY">
      <xsl:choose>
	<xsl:when test="floor(($minY - ($rangeY div 10)) &lt; 0) and ($minY &gt;= 0)">
  	  <xsl:value-of select="0"/>
        </xsl:when>
	<xsl:otherwise>
          <xsl:value-of select="floor($minY - ($rangeY div 10))"/>
	</xsl:otherwise>
      </xsl:choose>
    </xsl:param>
    
    <xsl:param name="ceilingY">
      <xsl:choose>
	<xsl:when test="ceiling(($maxY + ($rangeY div 10)) &gt; 0) and ($maxY &lt;= 0)">
	  <xsl:value-of select="0"/>
	</xsl:when>
	<xsl:otherwise>
          <xsl:value-of select="ceiling($maxY + ($rangeY div 10))"/>
	</xsl:otherwise>
      </xsl:choose>
    </xsl:param>

    <!-- Get the modulus of the max and min y values -->
    <xsl:param name="modFloorY">
      <xsl:choose>
	<xsl:when test="$floorY &lt; 0">
	  <!-- floorY is negative -->
	  <xsl:value-of select="-$floorY"/>
	</xsl:when>
	<xsl:otherwise>
	  <!-- floorY is non-negative -->
	  <xsl:value-of select="$floorY"/>
	</xsl:otherwise>
      </xsl:choose>
    </xsl:param>    

    <xsl:param name="modCeilingY">
      <xsl:choose>
	<xsl:when test="$ceilingY &lt; 0">
	  <!-- ceilingY is negative -->
	  <xsl:value-of select="-$ceilingY"/>
	</xsl:when>
	<xsl:otherwise>
	  <!-- ceilingY is non-negative -->
	  <xsl:value-of select="$ceilingY"/>
	</xsl:otherwise>
      </xsl:choose>
    </xsl:param>    

    <!-- Get the maximum of the two modulus values -->
    <xsl:param name="maxModY">
      <xsl:choose>
	<xsl:when test="$modFloorY &gt;= $modCeilingY">
	  <xsl:value-of select="$modFloorY"/>
	</xsl:when>
	<xsl:otherwise>
	  <xsl:value-of select="$modCeilingY"/>
	</xsl:otherwise>
      </xsl:choose>
    </xsl:param>

    <!-- Get the length of the maximum y-axis number -->
    <xsl:param name="yStringLength">
      <xsl:value-of select="string-length($maxModY)"/>
    </xsl:param>

    <!-- Chart Ranges -->    
    <xsl:param name="chartRangeX">
      <xsl:value-of select="$ceilingX - $floorX"/>
    </xsl:param>

    <xsl:param name="chartRangeY">
      <xsl:value-of select="$ceilingY - $floorY"/>
    </xsl:param>
    

    <!-- Chart starting position -->
    <xsl:param name='offsetX' select='40 + 20 * $yStringLength'/>
    <xsl:param name='offsetY' select='75'/>

    <!-- Padding for graph -->
    <xsl:param name='padLeft'   select="$floorX - $minX"/>
    <xsl:param name='padTop'    select="$floorY - $maxY"/>


    <!-- Work out the placing of the x-axis on the graph -->
    <xsl:param name="xAxisPosition">
      <xsl:choose>
        <xsl:when test="$maxY &gt; 0 and $rangeY &lt; $maxY">
	  <xsl:comment>The data is all positive</xsl:comment>
	  <xsl:value-of select="$offsetY + $chartY"/>
  	</xsl:when>
	<xsl:when test="$minY &lt; 0 and $rangeY &lt; ( -1 * $minY )">
	  <xsl:comment>The data is all negative</xsl:comment>
	  <xsl:value-of select="$offsetY"/>
	</xsl:when>
	<xsl:otherwise>
	  <xsl:comment>The data crosses zero on the y-axis</xsl:comment>
	  <xsl:value-of select="($offsetY) - ($chartY) * ( (0 - $minY + $padTop ) div $chartRangeY)"/>
	</xsl:otherwise>
      </xsl:choose>
    </xsl:param>

    <!-- Get the definition of the parameter being graphed for
      	 use within the title -->
    <xsl:param name="titleDefinition">
      	<xsl:call-template name="get.dictionary.reference.graph">
	  <xsl:with-param name="dictRef" select="$graphProperty"/>
	</xsl:call-template>
    </xsl:param>

    <xsl:result-document href="{$outputFile}" format="graph">
     
      <svg:svg xmlns:svg="http://www.w3.org/2000/svg" 
	  zoomAndPan="magnify" width="600" height="500">
        <svg:defs>
        <svg:style type="text/css">
          <xsl:text>
	    <![CDATA[
  	      .xAxisLabels {
		      text-anchor: middle;
		      fill: #000000;
		      font-size: 12px;
		      font-weight: normal;
	      }
	      .yAxisLabels {
		      text-anchor: end;
		      fill: #000000;
		      font-size: 12px;
		      font-weight: normal;
	      }
	      .line1 {
		      fill: none;
		      stroke: #ff0000;
		      stroke-width: 1px;	
	      }
	      .background {
		      fill: #ffffff;
		      stroke: #000000;
		      stroke-width: 1px;
	      }
	      .tick {
		      stroke: #000000;
		      stroke-width: 1px;
	      }
	      .axes {
		      stroke: #000000;
		      stroke-width: 3px;
	      }
	      .graphTitle {
		      text-anchor: middle;
		      fill: #000000;
		      font-size: 14px;
		      font-weight: bold;
	      }
	      .axisTitle {
		      text-anchor: middle;
		      fill: #000000;
		      font-size: 12px;
		      font-weight: bold;
	      }
	    ]]>
	  </xsl:text>
	</svg:style>
        </svg:defs>
 
        <xsl:comment> Main Canvas </xsl:comment>
        <svg:rect x='{$offsetX}' y='{$offsetY}' height='{$chartY}' 
  	  width='{$chartX}' class='background'/>

        <xsl:comment> The graph title </xsl:comment>
        <svg:text class="graphTitle" x="{$offsetX +( $chartX div 2)}" y="{$offsetY div 3}"><xsl:value-of select="$titleDefinition"/></svg:text>    
  
        <xsl:comment> Ticks along y </xsl:comment>
        <svg:line class="tick" x1="{$offsetX}" y1="{$offsetY}"
	  x2="{$offsetX - 5}" y2="{$offsetY}"/>
        <svg:line class="tick" x1="{$offsetX}" 
	  y1="{$offsetY + ($chartY div 4) }"   
	  x2="{$offsetX - 5}" y2="{$offsetY + ($chartY div 4) }"/>
        <svg:line class="tick" x1="{$offsetX}" 
	  y1="{$offsetY + 2*($chartY div 4) }" 
	  x2="{$offsetX - 5}" y2="{$offsetY + 2*($chartY div 4) }"/>
        <svg:line class="tick" x1="{$offsetX}" 
	  y1="{$offsetY + 3*($chartY div 4) }" 
	  x2="{$offsetX - 5}" y2="{$offsetY + 3*($chartY div 4) }"/>
        <svg:line class="tick" x1="{$offsetX}" 
	  y1="{$offsetY + $chartY }" 
	  x2="{$offsetX - 5}" y2="{$offsetY + $chartY }"/>

        <xsl:comment>Draw the x-axis - can't assume will be the bottom of the graph</xsl:comment>
        <svg:line class="axes" x1="{$offsetX}" y1="{$xAxisPosition}" x2="{$offsetX + $chartX}"
	  y2="{$xAxisPosition}"/>

        <xsl:comment>Draw the y-axis - for now assume it is down the left of the graph</xsl:comment>
        <svg:line class="axes" x1="{$offsetX}" y1="{$offsetY}" x2="{$offsetX}"
	  y2="{$offsetY + $chartY}"/>

        <xsl:comment> Ticks along x </xsl:comment>
        <xsl:variable name="tickY2Position">
	  <xsl:comment>If the x axis is at the top of the graph, draw the ticks up, else draw them down</xsl:comment>
	  <xsl:choose>
	    <xsl:when test="$xAxisPosition = $offsetY">
	      <xsl:value-of select="$xAxisPosition - 5"/>
	    </xsl:when>
	    <xsl:otherwise>
	      <xsl:value-of select="$xAxisPosition + 5"/>
	    </xsl:otherwise>
	  </xsl:choose>
        </xsl:variable>

        <svg:line class="tick" x1="{$offsetX}" 
	  y1="{$xAxisPosition}" x2="{$offsetX}" 
	  y2="{$tickY2Position}"/>
        <svg:line class="tick" x1="{$offsetX + ($chartX div 4) }" 
	  y1="{$xAxisPosition}" x2="{$offsetX + ($chartX div 4) }" 
	  y2="{$tickY2Position}"/>
        <svg:line class="tick" x1="{$offsetX + 2*($chartX div 4) }" 
	  y1="{$xAxisPosition}" x2="{$offsetX + 2*($chartX div 4) }" 
	  y2="{$tickY2Position}"/>
        <svg:line class="tick" x1="{$offsetX + 3*($chartX div 4) }" 
	  y1="{$xAxisPosition}" x2="{$offsetX + 3*($chartX div 4) }" 
	  y2="{$tickY2Position}"/>
        <svg:line class="tick" x1="{$offsetX + $chartX }" 
	  y1="{$xAxisPosition}" x2="{$offsetX + $chartX }" 
	  y2="{$tickY2Position}"/>
      
        <xsl:comment> Numbering along y </xsl:comment>
        <svg:text class="yAxisLabels" x="{$offsetX - 10}" y="{$offsetY + 5}">
          <xsl:value-of select="format-number($ceilingY, '0.00')"/>
        </svg:text>
        <svg:text class="yAxisLabels" x="{$offsetX - 10}" 
	  y="{$offsetY + ($chartY div 4)  + 5}">
          <xsl:value-of select="format-number($ceilingY - ($chartRangeY div 4), '0.00') "/>
        </svg:text>
        <svg:text class="yAxisLabels" x="{$offsetX - 10}" y="{$offsetY + 2*($chartY div 4)  + 5}">
          <xsl:value-of select="format-number($ceilingY - 2*($chartRangeY div 4), '0.00')"/>
        </svg:text>
        <svg:text class="yAxisLabels" x="{$offsetX - 10}" y="{$offsetY + 3*($chartY div 4)  + 5}">
          <xsl:value-of select="format-number($ceilingY - 3*($chartRangeY div 4), '0.00')"/>
        </svg:text>
        <svg:text class="yAxisLabels" x="{$offsetX - 10}" y="{$offsetY + $chartY  + 5}">
          <xsl:value-of select="format-number($floorY, '0.00')"/>
        </svg:text>

        <xsl:comment> Label for the y-axis</xsl:comment>
        <svg:text class="axisTitle" x="{$offsetX div 4}" 
	  y="{$offsetY + ($chartY div 2) }" transform="rotate(270, {$offsetX div 4}, {$offsetY + ($chartY div 2)})">
	  <xsl:value-of select="substring-after($graphProperty, ':')"/>
        </svg:text>      

        <xsl:comment> Numbering along x </xsl:comment>

        <xsl:variable name="numberingY2Position">
	  <xsl:comment>If the x axis is at the top of the graph, draw the numbers above, else draw them below</xsl:comment>
	  <xsl:choose>
	    <xsl:when test="$xAxisPosition = $offsetY">
	      <xsl:value-of select="$xAxisPosition - 10"/>
	    </xsl:when>
	    <xsl:otherwise>
	      <xsl:value-of select="$xAxisPosition + 20"/>
	    </xsl:otherwise>
	  </xsl:choose>
        </xsl:variable>

        <svg:text class="xAxisLabels" x="{$offsetX}" y="{$numberingY2Position}">
          <xsl:value-of select="format-number($floorX, '0.00')"/>
        </svg:text>
        <svg:text class="xAxisLabels" x="{$offsetX + ($chartX div 4) }" y="{$numberingY2Position}">
          <xsl:value-of select="format-number($floorX + ($chartRangeX div 4), '0.00')"/>
        </svg:text>
        <svg:text class="xAxisLabels" x="{$offsetX + 2*($chartX div 4) }" y="{$numberingY2Position}">
          <xsl:value-of select="format-number($floorX + 2*($chartRangeX div 4), '0.00')"/>
        </svg:text>
        <svg:text class="xAxisLabels" x="{$offsetX + 3*($chartX div 4) }" y="{$numberingY2Position}">
          <xsl:value-of select="format-number($floorX + 3*($chartRangeX div 4), '0.00')"/>
        </svg:text>
        <svg:text class="xAxisLabels" x="{$offsetX + $chartX }" y="{$numberingY2Position}">
          <xsl:value-of select="format-number($ceilingX, '0.00')"/>
        </svg:text>

        <xsl:comment> Label for the x-axis </xsl:comment>
        <xsl:variable name="xAxisLabelYPosition">
	  <xsl:comment>
	    If the x axis is at the top of the graph, draw the label above the graph,
	    if it is at the bottom, draw the label below, if it somewhere in the middle draw the 
	    label to the end of the axis
	  </xsl:comment>

	  <xsl:choose>
	    <xsl:when test="$xAxisPosition = $offsetY">
	      <xsl:value-of select="2 * $offsetY div 3"/>
	    </xsl:when>
	    <xsl:when test="$xAxisPosition = ($offsetY + $chartY)">
	      <xsl:value-of select="$offsetY + $chartY + 40"/>
	    </xsl:when>
	    <xsl:otherwise>
	      <xsl:value-of select="$xAxisPosition"/>
	    </xsl:otherwise>
	  </xsl:choose>
        </xsl:variable>

        <xsl:variable name="xAxisLabelXPosition">
	  <xsl:comment>
	    If the x axis is at the top of the graph, draw the label above the graph,
	    if it is at the bottom, draw the label below, if it somewhere in the middle draw the 
	    label to the end of the axis
	  </xsl:comment>

	  <xsl:choose>
	    <xsl:when test="($xAxisPosition = $offsetY) or ($xAxisPosition = ($offsetY + $chartY))">
	      <xsl:value-of select="$offsetX + ($chartX div 2)"/>
	    </xsl:when>
	    <xsl:otherwise>
	      <xsl:value-of select="$offsetX + $chartX + 20"/>
	    </xsl:otherwise>
	  </xsl:choose>
        </xsl:variable>

        <svg:text class="axisTitle" x="{$xAxisLabelXPosition}" y="{$xAxisLabelYPosition}">
	  Step
        </svg:text>      

        <xsl:comment> Points on graph </xsl:comment>

        <xsl:choose>
	  <xsl:when test="$graphType = 'step'">
	    <xsl:for-each select="//cml/step">
	      <svg:circle r="2">
	        <xsl:attribute name="cx">
	          <xsl:value-of select="$offsetX + ($chartX * ( (position() - $floorX + $padLeft + $minX) div $chartRangeX) )"/>
	        </xsl:attribute>
	        <xsl:attribute name="cy">
	          <xsl:value-of select="$offsetY - $chartY * ( (propertyList/property[@dictRef=$graphProperty]/scalar - $minY + $padTop) div $chartRangeY)"/>
	        </xsl:attribute>
	      </svg:circle>
	    </xsl:for-each>
	  </xsl:when>
	  <xsl:when test="$graphType = 'scfStep'">
	    <xsl:for-each select="//cml/step">
	      <xsl:if test="position() = $position">
	        <xsl:for-each select="step">
 	          <svg:circle r="2">
  	            <xsl:attribute name="cx">
	              <xsl:value-of select="$offsetX + ($chartX * ( (position() - $floorX + $padLeft + $minX) div $chartRangeX) )"/>
	            </xsl:attribute>
	            <xsl:attribute name="cy">
 	              <xsl:value-of 
		        select="($offsetY) - ($chartY) * ( (propertyList/property[@dictRef=$graphProperty]/scalar - $minY + $padTop ) div $chartRangeY)"/>
	            </xsl:attribute>
	          </svg:circle>
	        </xsl:for-each>
	      </xsl:if>
	    </xsl:for-each>
	  </xsl:when>
        </xsl:choose>
   
        <xsl:comment> Lines on graph </xsl:comment>

        <xsl:choose>
	  <xsl:when test="$graphType = 'step'">
	    <svg:polyline class="line1">
	      <xsl:attribute name="points">
	        <xsl:for-each select="//cml/step">
                  <xsl:value-of select="$offsetX + ($chartX * ( (position() - $floorX + $padLeft + $minX) div $chartRangeX ) )"/><xsl:text>, </xsl:text>
                  <xsl:value-of select="($offsetY) - ($chartY) * ( (propertyList/property[@dictRef=$graphProperty]/scalar - $minY + $padTop ) div $chartRangeY)"/><xsl:text> </xsl:text>
	        </xsl:for-each>
	      </xsl:attribute>
	    </svg:polyline>
	  </xsl:when>
	  <xsl:when test="$graphType = 'scfStep'">
	    <xsl:for-each select="//cml/step">
	      <xsl:if test="position() = $position">
 	        <svg:polyline class="line1">
	          <xsl:attribute name="points">
	            <xsl:for-each select="step">
                      <xsl:value-of select="$offsetX + ($chartX * ( (position() - $floorX + $padLeft + $minX) div $chartRangeX ) )"/><xsl:text>, </xsl:text>
                      <xsl:value-of select="($offsetY) - ($chartY) * ( (propertyList/property[@dictRef=$graphProperty]/scalar - $minY + $padTop ) div $chartRangeY)"/><xsl:text> </xsl:text>
	            </xsl:for-each>
	          </xsl:attribute>
	        </svg:polyline>	        
	      </xsl:if>
	    </xsl:for-each>
	  </xsl:when>
        </xsl:choose>

      </svg:svg>

    </xsl:result-document>
    
  </xsl:template>

  <xsl:template match="*"/>

</xsl:stylesheet>
EOF
cat > $TMPXSLTDIR/dict2frag.xsl << "EOF"
<?xml version="1.0" encoding="UTF-8" ?>

<xsl:stylesheet version="1.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	xmlns:stm="http://www.xml-cml.org/schema/stmml"
        xmlns="http://www.w3.org/1999/xhtml"
        exclude-result-prefixes="xsl stm"
        >

  <xsl:template name="addDict">
    <xsl:apply-templates select="document(concat($prog,'Dict.xml'))/stm:dictionary/stm:entry">
      <!-- need translate below to prevent separating upper & lower case entries -->
      <xsl:sort data-type="text" order="ascending" 
		select="translate(@term,'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')"/>
    </xsl:apply-templates> 
  </xsl:template>

</xsl:stylesheet>
EOF
cat > $TMPXSLTDIR/dict2html.xsl << "EOF"
<?xml version="1.0" encoding="UTF-8" ?>

<xsl:stylesheet version="1.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	xmlns:stm="http://www.xml-cml.org/schema/stmml"
        xmlns="http://www.w3.org/1999/xhtml"
        >

  <xsl:import href="dictcommon.xsl"/>

  <xsl:output method="xml" version="1.0" encoding="UTF-8" 
    omit-xml-declaration="no" standalone="yes"
    doctype-public="-//W3C//DTD XHTML 1.0 Strict//EN"
    doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
    indent="yes" media-type="application/xhtml+xml"/>

  <xsl:template match="/">
    <html>
      <head>
	<title><xsl:value-of select="/stm:dictionary/@title"/></title>
      </head>
    <body>
      <h1><xsl:value-of select="/stm:dictionary/@title"/></h1>
      <hr></hr>
      <xsl:apply-templates select="/stm:dictionary/stm:entry">
	<!-- need translate below to prevent separating upper & lower case entries -->
        <xsl:sort data-type="text" order="ascending" 
		  select="translate(@term,'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')"/>
      </xsl:apply-templates>
    </body>
  </html>
</xsl:template>

</xsl:stylesheet>
EOF
cat > $TMPXSLTDIR/dict2xsl.xsl << "EOF"
<?xml version="1.0" encoding="UTF-8" ?>

<xsl:stylesheet version="1.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	xmlns:stm="http://www.xml-cml.org/schema/stmml"
        xmlns="http://www.w3.org/1999/xhtml"
        >

  <xsl:import href="dictcommon.xsl"/>

  <xsl:output method="xml" version="1.0" encoding="UTF-8" 
    omit-xml-declaration="no" standalone="yes"
    indent="yes" media-type="text/xsl"/>

  <xsl:template match="/">
    <xsl:element name="xsl:stylesheet" namespace="http://www.w3.org/1999/XSL/Transform">
      <xsl:attribute name="version">1.0</xsl:attribute>
 <!--      <xsl:attribute name="xmlns">http://www.w3.org/1999/xhtml</xsl:attribute> -->
      <xsl:element name="xsl:template" namespace="http://www.w3.org/1999/XSL/Transform">
	<xsl:attribute name="name">addDict</xsl:attribute>
	<xsl:apply-templates select="//stm:entry">
	  <!-- need translate below to prevent separating upper & lower case entries -->
	  <xsl:sort data-type="text" order="ascending" 
		    select="translate(@term,'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')"/>
	</xsl:apply-templates>
      </xsl:element>
    </xsl:element>
  </xsl:template>

</xsl:stylesheet>
EOF
cat > $TMPXSLTDIR/dictcommon.xsl << "EOF"
<?xml version="1.0" encoding="UTF-8" ?>

<xsl:stylesheet version="1.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	xmlns:stm="http://www.xml-cml.org/schema/stmml"
        xmlns="http://www.w3.org/1999/xhtml"
        exclude-result-prefixes="xsl stm"
        >

  <!-- For each entry in the dictionary -->
  <xsl:template match="stm:entry">
    <div class="dictAnchor">
      <a>
	<xsl:attribute name="name">
	  <xsl:value-of select="@id"/>
	</xsl:attribute>
      </a>
    </div>
    <div class="dictEntry"><xsl:value-of select="@term"/><xsl:text>:</xsl:text></div>
    <xsl:if test="stm:definition">
      <xsl:choose>
	<xsl:when test="//text()='definition to be supplied'">
	  <p><font color="blue"><xsl:value-of select="stm:definition"/></font></p>
	</xsl:when>
	<xsl:otherwise>
	  <div class="dictDefinition"><xsl:value-of select="stm:definition"/></div>
	</xsl:otherwise>
      </xsl:choose>
    </xsl:if>
    <xsl:if test="stm:description">
      <xsl:copy-of select="stm:description/node()"/>
    </xsl:if>
    <hr/>
  </xsl:template>
  
  
  <!-- for each description just copy everything -->
  <!-- REM do the same for MathML stuff          -->
<!--  <xsl:template match="stm:description/@*|node()">
    <xsl:copy>
      <xsl:apply-templates select="@*|node()"/>
    </xsl:copy>
  </xsl:template> -->


  
</xsl:stylesheet>
EOF
cat > $TMPXSLTDIR/dictionary.xsl << "EOF"
<?xml version="1.0" encoding="UTF-8" ?>
<!--===================== DICTIONARY =========================-->

<xsl:stylesheet version="1.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	xmlns:stm="http://www.xml-cml.org/schema/stmml"
        xmlns="http://www.w3.org/1999/xhtml"
        exclude-result-prefixes="xsl stm"
	>
  
  <!-- GET DICTIONARY REFERENCE FOR USE WITHIN THE HTML OUTPUT -->	
  <xsl:template name="get.dictionary.reference.html">
    <!-- if dictionary reference is given try to resolve it -->
    <xsl:param name="dictRef" select="' '"/>
    <xsl:param name="title" select="' '"/>
    <xsl:choose>
      <xsl:when test="$dictRef">
          <xsl:call-template name="resolve.dictionary.id.html">
	    <xsl:with-param name="dictionary" select="document(concat(substring-before($dictRef, ':'), 'Dict.xml'))"/>
	    <xsl:with-param name="entry" select="substring-after(@dictRef, ':')"/>
	  </xsl:call-template>
      </xsl:when>
      <xsl:when test="not($dictRef) and $title">                
        <span>
	  <i><xsl:value-of select="$title"/></i>
	</span>
      </xsl:when>
    </xsl:choose>
  </xsl:template>


<!-- RESOLVE DICTIONARY ID FOR THE HTML OUTPUT -->
  <xsl:template name="resolve.dictionary.id.html">
    <xsl:param name="dictionary"/>
    <xsl:param name="entry"/>
    <xsl:variable name="title">
      <xsl:choose>
        <xsl:when test="@title">
	  <xsl:value-of select="@title"/>
	</xsl:when>
	<xsl:otherwise>
          <xsl:text>Unknown</xsl:text>  
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>

    <xsl:choose>
    <!-- If dictionary exists use it-->  
      <xsl:when test="$dictionary/stm:dictionary/stm:entry[@id =  $entry]">
        <xsl:apply-templates select="$dictionary/stm:dictionary/stm:entry[@id = $entry]" mode="htmlOutput">
          <xsl:with-param name="entry" select="$entry"/>
	  <xsl:with-param name="title" select="$title"/>
        </xsl:apply-templates>
      </xsl:when>
    <!-- If dictionary does NOT exist use entry name and flag a warning -->  
      <xsl:otherwise>
        <xsl:choose>
        <xsl:when test="$title = 'Unknown'">
          <xsl:value-of select="$entry"/>            <!-- 2nd failing that use @dictRef -->
	</xsl:when>
	<xsl:otherwise>
	  <xsl:value-of select="$title"/>            <!-- 1st preferentially use @title -->
	</xsl:otherwise>
      </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>


  <!-- GET DICTIONARY ENTRY FOR HTML OUTPUT -->	
  <xsl:template match="stm:entry" mode="htmlOutput">
    <xsl:param name="entry"/>
    <xsl:param name="title"/>
    <xsl:variable name="dictTitle">
      <xsl:choose>
        <xsl:when test="$title = 'Unknown'">
          <xsl:choose>
	    <xsl:when test="@term">
	      <xsl:value-of select="@term"/>             <!-- 2nd otherwise use @term -->
	    </xsl:when>
	    <xsl:otherwise>
	      <xsl:value-of select="$entry"/>            <!-- 3rd failing that use @dictRef -->
	    </xsl:otherwise>
	  </xsl:choose>
	</xsl:when>
	<xsl:otherwise>
	  <xsl:value-of select="$title"/>                  <!-- 1st preferentially use @title -->
	</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>  
    <span>
      <xsl:attribute name="onmouseover">document.location.href='#<xsl:value-of select="@id"/>';</xsl:attribute>
      <xsl:value-of select="$dictTitle"/>
    </span>
  </xsl:template>
  
  
  
  
<!-- GRAPH -->
  <!-- GET DICTIONARY REFERENCE FOR USE WITHIN THE GRAPH OUTPUT -->	
  <xsl:template name="get.dictionary.reference.graph">
    <!-- if dictionary reference is given try to resolve it -->
    <xsl:param name="dictRef"/>
    <xsl:choose>
      <xsl:when test="$dictRef">
	<xsl:call-template name="resolve.dictionary.id.graph">
	  <xsl:with-param name="dictionary" 
	     select="document(concat(substring-before($dictRef, ':'), 'Dict.xml'))"/>
	  <xsl:with-param name="entry" select="substring-after($dictRef, ':')"/>
	</xsl:call-template>
      </xsl:when>
      <!-- else try to use the title attribute and flag a warning -->
      <xsl:when test="@title">
	<xsl:text>No dictionary reference given</xsl:text>
      </xsl:when>
      <!-- otherwise just write 'unknown' and flag a warning -->
      <xsl:otherwise>
	<xsl:text>No dictionary reference or title given</xsl:text>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
  
  
  <!-- RESOLVE DICTIONARY ID FOR THE GRAPH OUTPUT-->	
  <xsl:template name="resolve.dictionary.id.graph">
    <xsl:param name="dictionary"/>
    <xsl:param name="entry"/>
    <xsl:choose>
      
      <!-- If dictionary exists use it-->  
      <xsl:when test="$dictionary/dictionary">

        <!-- If entry found then use it -->
	<xsl:if test="$dictionary/dictionary/entry[@id =  $entry]">
	  <xsl:apply-templates select="$dictionary/dictionary/entry[@id =  $entry]" mode="graphOutput">
	    <xsl:with-param name="entry" select="$entry"/>
	  </xsl:apply-templates>
	</xsl:if>
	
	<!--  If entry NOT found then use entry name and flag a warning  -->
	<xsl:if test="not($dictionary/dictionary/entry[@id =  $entry])">
	  <xsl:text>Entry </xsl:text><xsl:value-of select="$entry"/>
	  <xsl:text> not found in the dictionary</xsl:text>
	</xsl:if>
      </xsl:when>
      
      <!-- If dictionary does NOT exist use entry name and flag a warning -->  
      <xsl:otherwise>
	<xsl:value-of select="$dictionary"/><xsl:text> dictionary not found.</xsl:text>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>


  <!-- GET DICTIONARY ENTRY FOR GRAPH OUTPUT -->
  <xsl:template match="entry" mode="graphOutput">
    <xsl:param name="entry"/>

    <xsl:value-of select="definition"/>
  </xsl:template>

</xsl:stylesheet>
EOF
cat > $TMPXSLTDIR/display.xsl << "EOF"
<?xml version="1.0" encoding="UTF-8" ?>

<xsl:stylesheet version="1.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        xmlns:cml="http://www.xml-cml.org/schema"
        xmlns="http://www.w3.org/1999/xhtml"
        exclude-result-prefixes="xsl"
        >

<!-- CML -->
<xsl:import href="structure.xsl"/>
<xsl:import href="dictionary.xsl"/>
<xsl:import href="metadata.xsl"/>
<xsl:import href="parameter.xsl"/>
<xsl:import href="property.xsl"/>
<xsl:import href="bandList.xsl"/>
<xsl:import href="formula.xsl"/>
<xsl:import href="units.xsl"/>

<!-- CMLComp -->
<xsl:import href="module.xsl"/>
<xsl:import href="lattice.xsl"/>

<!-- STMML -->
<xsl:import href="scalar.xsl"/>
<xsl:import href="array.xsl"/> 
<xsl:import href="matrix.xsl"/>
<xsl:import href="table.xsl"/>

<!-- Dictionary -->
<xsl:import href="dict2frag.xsl"/>
<xsl:import href="dictcommon.xsl"/>

<!-- Special templates -->
<xsl:import href="summary.xsl"/>
<xsl:import href="rdf.xsl"/>

<xsl:strip-space elements="*"/>

<xsl:template match="text()"/>

<!-- Global Variable holding the program name -->
<xsl:param name="prog">
  <xsl:choose>
    <xsl:when test="/cml:cml/cml:metadataList/cml:metadata[@name='eMinerals:Program']">
     <xsl:value-of select="/cml:cml/cml:metadataList/cml:metadata[@name='eMinerals:Program']/@content"/>
    </xsl:when>
    <xsl:when test="/cml:cml/cml:metadataList/cml:metadata[@name='siesta:Program']">
     <xsl:value-of select="/cml:cml/cml:metadataList/cml:metadata[@name='siesta:Program']/@content"/>
    </xsl:when>
    <xsl:when test="/cml:cml/cml:metadataList/cml:metadata[@name='dl_poly:Program']">
     <xsl:value-of select="/cml:cml/cml:metadataList/cml:metadata[@name='dl_poly:Program']/@content"/>
    </xsl:when>
    <!-- <xsl:when test="/cml:cml/cml:metadataList/cml:metadata[@name='dc:creator']">
    <xsl:message> Three </xsl:message>
     <xsl:value-of select="/cml:cml/cml:metadata[@name='dc:creator']/@content"/>
    </xsl:when> -->
    <xsl:when test="/cml:cml/cml:metadataList/cml:metadata[@name='dc:identifier']/@content = 'DL_POLY version 3.06 / March 2006'">
      <xsl:text>DL_POLY</xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:text>Program</xsl:text>
    </xsl:otherwise>
  </xsl:choose>
</xsl:param>

<!-- Global variable - do we want jmol output or not? -->
  <xsl:param name="Jmol">
    <xsl:value-of select="boolean(//cml:molecule)"/>
  </xsl:param>

<!-- Global variable - how many steps do we want? -->
  <xsl:param name="stepinterval">
    <xsl:choose>
      <xsl:when test="count(cml:cml/cml:module[@role='step']) &gt; 100">
         10
      </xsl:when>
      <xsl:otherwise>
         1
      </xsl:otherwise>
    </xsl:choose>
  </xsl:param>


  <xsl:output method="xml" version="1.0" encoding="UTF-8" 
    omit-xml-declaration="no" standalone="yes"
    doctype-public="-//W3C//DTD XHTML 1.0 Strict//EN"
    doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
    indent="yes" media-type="application/xhtml+xml"/>


<!-- MAIN TEMPLATE -->
  <xsl:template match="/">
    <html>
      <head>
	<title>
	  <xsl:value-of select="$prog"/>
	  <xsl:text> Output</xsl:text>
	</title>
        <style type="text/css">
          <xsl:call-template name="css-style"/>
        </style>
        <xsl:if test="$Jmol!='false'">
          <script type="text/javascript" src="http://www.eminerals.org/jmol/JmolX.js"/>
        </xsl:if>

        <script type="text/javascript">
          <xsl:call-template name="mainJavascript"/>
        </script>
      </head>

      <body>
        <xsl:if test="$Jmol!='false'">
         <xsl:attribute name="onload">
           <xsl:text>jmolXInitialize(&quot;http://www.eminerals.org/jmol&quot;)</xsl:text>
         </xsl:attribute>
        </xsl:if>
 
        <div id="head"><div class="bigTitle">
           <xsl:value-of select="$prog"/>
           <xsl:text> Output</xsl:text>
        </div></div>

<!-- Generate body of document -->
        <div id="maindisplay">
          <div class="innerMain">

            <br/><div onclick="js:togglemenu(&quot;initialMetadata&quot;)" class="divisionTitle clickableDiv">
              <xsl:value-of select="'Initial Metadata'"/>
            </div>
            <div class="sublevel" id="initialMetadata">
              <xsl:apply-templates select="/cml:cml/cml:metadataList[position()=1]"/>
            </div><br/>

            <br/><div onclick="js:togglemenu(&quot;inputParams&quot;)" class="divisionTitle clickableDiv">
              <xsl:value-of select="'Input Parameters'"/>
            </div>
            <div class="sublevel" id="inputParams">
              <xsl:apply-templates select="/cml:cml/cml:parameterList"/>
            <!--   <xsl:apply-templates select="/cml:cml/cml:parameterList[position()=1]"/> -->
            </div><br/>

            <br/><div onclick="js:togglemenu(&quot;initialState&quot;)" class="divisionTitle clickableDiv">
              <xsl:value-of select="'Input State of System'"/>
            </div>
            <div class="sublevel" id="initialState">
              <xsl:apply-templates select="/cml:cml/cml:module[@title='Initial System']" mode="noTitle"/>
            </div><br/>

            <br/><div onclick="js:togglemenu(&quot;mainBody&quot;)" class="divisionTitle clickableDiv">
              <xsl:value-of select="'Main Body of Simulation'"/>
            </div>
            <div class="sublevel" id="mainBody">
              <xsl:apply-templates select="/cml:cml/cml:module[(@title!='Initial System' and @title!='Finalization') or not(@title)]"/>
            </div><br/>

            <br/><div onclick="js:togglemenu(&quot;finalState&quot;)" class="divisionTitle clickableDiv">
              <xsl:value-of select="'Final State of System'"/>
            </div>
            <div class="sublevel" id="finalState">
              <xsl:apply-templates select="/cml:cml/cml:module[@title='Finalization']" mode="noTitle"/>
            </div><br/>

            <br/>
            <div onclick="js:togglemenu(&quot;summaryInfo&quot;)" class="divisionTitle clickableDiv">
              <xsl:text>Summary Information</xsl:text>
            </div>
            <div class="sublevel" id="summaryInfo">
              <xsl:call-template name="summary"/>
	    </div>
            <br/>
            <hr/>
          </div>
        </div>

<!-- Generate dictionary of document -->
        <div id="dictdisplay">
          <div class="innerDict">
            <xsl:call-template name="addDict"/>
          </div>
        </div>
<!-- -->

        <div id="foot">
          <i>Created by Toby White, Jon Wakelin,  &amp; Richard Bruin </i>
        </div>

      </body>
    </html>

  </xsl:template>

  <xsl:template name="top.level.section">
    <xsl:param name="uid"/>
    <xsl:param name="title"/>
    <xsl:param name="templates"/>
  </xsl:template>

  <xsl:template name="css-style">
    <xsl:text>
      <![CDATA[
        html       {
                     height:100%;
                     max-height:100%;
                     padding:0;
                     margin:0;
                     border:0;
                     background:#fff;
                     overflow: hidden;
                   }
        body       {
                     font-family: serif;
                     background: #ffffff;
                     height:100%;
                     max-height:100%;
                     overflow:hidden;
                     padding:0;
                     margin:0;
                     border:0;
                   }
        table      { text-align: center; 
		     border-collapse: collapse; 
		     }
	table.prop { 
	  	     text-align: right; 
	             border-collapse: collapse; 
	             border-left: hidden; 
		     border-right: hidden;
		     border-top: 1px solid Gray; 
		     border-bottom: 1px solid Gray; 
		     }
        table.structure { background: #ffffff; }

        .step       { 
                      border: 1px solid Gray;
                    }
        th.step     {
                      background: #aa2222;
                    }
        td.step     {
                      font-family: monospace;
                      background: #cc9999;
                    }
        td.stepnum { background: #ffffff; ; }

        .coords { border: 1px solid Gray;}

	.graph     {
                     text-align: left;
                   }
	
	th        { font-weight: bold; }
	td        { padding-left: 7px; padding-right: 7px;}
	.bigTitle 
                  {
                    color: #ffffff; 
                    background: Navy;    
                    font-weight: bold; 
                    margin: 0px; 
                    padding: 2px;
                    font-size: xx-large;
                  }
	.divisionTitle {
                  }
        .listTitle
                  {
                    font-weight: 900;
                    font-size: x-large;
                    margin-top: 2.5ex;
                    margin-bottom: 2.5ex;
                  }
	.clickable { 
                    text-decoration: underline;
                    color: #ffffff; 
                    background: #4682B4; 
                    cursor: pointer; 
                   }
	.eigen    { text-align: right; padding-left: 7px; padding-right: 7px; }
	.band     { vertical-align: text-top; }
	.toplevel { display: block; font-weight: 400; margin-bottom: 0; }
        .clickableDiv {color: #ffffff;
                    background: #4682B4;
                    font-weight: bold;
                    font-size: x-large;
                    border-top-width: 0px;
                    border-left-width: 0px;
                    border-right-width: 5px;
                    border-bottom-width: 5px;
                    border-color: #7dB7FF;
                    border-style: solid;
                    }
        .clickableDiv:hover {
                    color: #9999ff; 
                    }
        .moduletitle {
                    padding: 5px;
                    margin-top: 10px;
                    margin-bottom: 10px;
                     }
        .steptitle   {
                    padding: 5px;
                    margin-top: 10px;
                    margin-bottom: 10px;
                     }
        .switch      { color: #ffffff;
                       background: #4682B4;
                       font-weight: bold;
                       cursor: pointer;
                       display: inline;
                       font-size: medium; }
	.sublevel { display: none; font-weight: normal; margin-left: 20px; margin-top: 0; line-height: 14px; }
        .paramname {color: #0000ff; }
        .paramvalue {color: #ff0000; }
        #head        {
                       position:absolute; margin:0; top:0; left:0; display:block; width:100%; height:50px; z-index:5; color:#fff; background: Navy;
                     }
        #foot        {
                       position:absolute; margin:0; bottom:0; left:0; display:block; width:100%; height:25px; background:rgb(233,238,242); font-size:0.8em; z-index:5; text-align:right; color:rgb(157,78,84);
                     }
        #maindisplay {
                       position:absolute;
                       left:0;
                       top:50px;
                       bottom:25px;
                       z-index: 4;
                       width:80%;
                       overflow:auto;
                     }
        #dictdisplay {
                       position:absolute;
                       left:80%;
                       top:50px;
                       bottom:25px;
                       z-index: 4;
                       width:20%;
                       overflow:auto;
                     }
        * html #maindisplay, * html #dictdisplay {
                       height:100%;
                       top:0;
                       bottom:0;
                       border-top:50px solid #fff;
                       border-bottom:25px solid #fff;}
        .innerMain  {
                       display:block;
                       padding:0 10px 10px 10px;
                    }
        .innerDict {
                       display:block;
                       padding:0 10px 10px 10px;
                       padding-bottom:300%;
                    }

        .dictEntry  { 
                       font-family: sans-serif;
                       font-weight: bold;
                       font-size: medium;
                    }
        .dictDefinition { 
                       font-family: serif;
                       font-weight: normal;
                       font-size: small; 
                         }
        .dictDescription { 
                       font-family: serif;
                       font-weight: normal;
                       font-size: small; 
                       font-style: italic;
                         }

      ]]>
    </xsl:text>
  </xsl:template>

  <xsl:template name="mainJavascript">
    <xsl:text>
      //<![CDATA[
      function togglemenu(submenu) { 
        if (document.getElementById(submenu).style.display == "none") {
          document.getElementById(submenu).style.display = "block";
        }
        else {
          document.getElementById(submenu).style.display = "none";
         }
      }

      function toggleButton(button, submenu) { 
        if (document.getElementById(submenu).style.display == "none") {
          document.getElementById(submenu).style.display = "block";
          button.setAttribute('value', 'Hide');
        }
        else {
          document.getElementById(submenu).style.display = "none";
          button.setAttribute('value', 'Show');
         }
      }

      function toggleJmol(sz, inputNode, thisId, parentId) {
        // Grab object node to be created.
        var appNode = document.getElementById(parentId);

        if (appNode.hasChildNodes()) {
          var newAppNode = document.createElementNS('http://www.w3.org/1999/xhtml','object');
          newAppNode.setAttribute('style', "display:none;")
          var newMessage = 'Activate Jmol viewer';
        }
        else {
          var newAppNode = jmolXAppletNodeId(sz, thisId, "background white", nameSuffix=thisId);
          var newMessage = 'Deactivate Jmol viewer';
        }
        appNode.parentNode.replaceChild(newAppNode, appNode);
        inputNode.setAttribute('value', newMessage);
      }

      //]]>
    </xsl:text>
  </xsl:template>

</xsl:stylesheet>
EOF
cat > $TMPXSLTDIR/dlpolygraphs.xsl << "EOF"
<?xml version="1.0" encoding="UTF-8" ?>
<xsl:stylesheet version="1.0"
        xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        xmlns="http://www.w3.org/1999/xhtml"
        xmlns:exsl="http://exslt.org/common"
        xmlns:cml="http://www.xml-cml.org/schema"
	xmlns:dl_poly="http://www.cse.clrc.ac.uk/msi/software/DL_POLY/namespace"
        extension-element-prefixes="exsl"
        >

  <xsl:import href="graph_bits.xsl"/>
  
  <xsl:template name="dlpolyGraphs">
    <div class="listTitle">Graphs with timestep</div>
    <table class="graph">
    <xsl:for-each select="//cml:step[position()=1]/cml:propertyList/cml:property">
      <xsl:if test="cml:scalar">
	<xsl:variable name="units" select="cml:scalar/@units"/>
	<xsl:variable name="dictName">
	  <xsl:call-template name="get.dictionary.reference.html">
	    <xsl:with-param name="dictRef" select="@dictRef"/>
	    <xsl:with-param name="title" select="@title"/>
	  </xsl:call-template>
	</xsl:variable>
        <xsl:variable name="graphId" select="generate-id()"/>
        <xsl:variable name="graphNodeSet">
	  <xsl:call-template name="selectNestedGraphNodes">
	    <xsl:with-param name="stepType" select="'MD'"/>
	    <xsl:with-param name="propertyName" select="@dictRef"/>
	  </xsl:call-template>
	</xsl:variable>
	<xsl:variable name="graph">
	  <xsl:call-template name="drawGraph">
	    <xsl:with-param name="graphTitle" select="$dictName"/>
	    <xsl:with-param name="xAxisTitle" select="'Step'"/>
	    <xsl:with-param name="yAxisTitle" select="$units"/>
	    <xsl:with-param name="pointSet" select="exsl:node-set($graphNodeSet)"/>
          </xsl:call-template> 
        </xsl:variable>
	<tr class="graph">
	  <td class="graph"><xsl:value-of select="$dictName"/>:</td>
          <td class="graph"><input type="button" value="Show" onclick="js:toggleButton(this, &quot;{$graphId}&quot;)"/></td><br/>
	<div style="display:none;" id="{$graphId}"><xsl:copy-of select="$graph"/></div>
	</tr>
      </xsl:if>
    </xsl:for-each>
  </table>
  </xsl:template>
</xsl:stylesheet>
  
EOF
cat > $TMPXSLTDIR/eMinViz.xsl << "EOF"
<?xml version="1.0" encoding="UTF-8" ?>

<xsl:stylesheet version="1.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        xmlns:cml="http://www.xml-cml.org/schema"
        xmlns="http://www.w3.org/1999/xhtml"
        exclude-result-prefixes="xsl"
        >

<!-- CML -->
<xsl:import href="structure.xsl"/>
<xsl:import href="dictionary.xsl"/>
<xsl:import href="metadata.xsl"/>
<xsl:import href="parameter.xsl"/>
<xsl:import href="property.xsl"/>
<xsl:import href="bandList.xsl"/>
<xsl:import href="formula.xsl"/>
<xsl:import href="units.xsl"/>

<!-- CMLComp -->
<xsl:import href="module.xsl"/>
<xsl:import href="lattice.xsl"/>

<!-- STMML -->
<xsl:import href="scalar.xsl"/>
<xsl:import href="array.xsl"/> 
<xsl:import href="matrix.xsl"/>
<xsl:import href="table.xsl"/>

<!-- Dictionary -->
<xsl:import href="dict2frag.xsl"/>
<xsl:import href="dictcommon.xsl"/>

<!-- Special templates -->
<xsl:import href="summary.xsl"/>
<xsl:import href="rdf.xsl"/>

<xsl:strip-space elements="*"/>

<xsl:template match="text()"/>

<!-- Global Variable holding the program name -->
<xsl:param name="prog">
  <xsl:choose>
    <xsl:when test="/cml:cml/cml:metadataList/cml:metadata[@name='siesta:Program']">
     <xsl:value-of select="/cml:cml/cml:metadataList/cml:metadata[@name='siesta:Program']/@content"/>
    </xsl:when>
    <xsl:when test="/cml:cml/cml:metadataList/cml:metadata[@name='dl_poly:Program']">
     <xsl:value-of select="/cml:cml/cml:metadataList/cml:metadata[@name='dl_poly:Program']/@content"/>
    </xsl:when>
    <!-- <xsl:when test="/cml:cml/cml:metadataList/cml:metadata[@name='dc:creator']">
    <xsl:message> Three </xsl:message>
     <xsl:value-of select="/cml:cml/cml:metadata[@name='dc:creator']/@content"/>
    </xsl:when> -->
    <xsl:when test="/cml:cml/cml:metadataList/cml:metadata[@name='dc:identifier']/@content = 'DL_POLY version 3.06 / March 2006'">
      <xsl:text>DL_POLY</xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:text>Program</xsl:text>
    </xsl:otherwise>
  </xsl:choose>
</xsl:param>

<!-- Global variable - do we want jmol output or not? -->
  <xsl:param name="Jmol">
    <xsl:value-of select="boolean(//cml:molecule)"/>
  </xsl:param>

<!-- Global variable - how many steps do we want? -->
  <xsl:param name="stepinterval">
    <xsl:choose>
      <xsl:when test="count(cml:cml/cml:module[@role='step']) &gt; 100">
         10
      </xsl:when>
      <xsl:otherwise>
         1
      </xsl:otherwise>
    </xsl:choose>
  </xsl:param>


  <xsl:output method="xml" version="1.0" encoding="UTF-8" 
    omit-xml-declaration="no" standalone="yes"
    doctype-public="-//W3C//DTD XHTML 1.0 Strict//EN"
    doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
    indent="yes" media-type="application/xhtml+xml"/>


<!-- MAIN TEMPLATE -->
  <xsl:template match="/">
    <html>
      <head>
	<title>
	  <xsl:value-of select="$prog"/>
	  <xsl:text> Output</xsl:text>
	</title>
        <style type="text/css">
          <xsl:call-template name="css-style"/>
        </style>
        <xsl:if test="$Jmol!='false'">
          <script type="text/javascript" src="http://www.eminerals.org/jmol/JmolX.js"/>
        </xsl:if>

        <script type="text/javascript">
          <xsl:call-template name="mainJavascript"/>
        </script>
      </head>

      <body>
        <xsl:if test="$Jmol!='false'">
         <xsl:attribute name="onload">
           <xsl:text>jmolXInitialize(&quot;http://www.eminerals.org/jmol&quot;)</xsl:text>
         </xsl:attribute>
        </xsl:if>
 
        <div id="head"><div class="bigTitle">
           <xsl:value-of select="$prog"/>
           <xsl:text> Output</xsl:text>
        </div></div>

<!-- Generate body of document -->
        <div id="maindisplay">
          <div class="innerMain">

            <br/><div onclick="js:togglemenu(&quot;initialMetadata&quot;)" class="divisionTitle clickableDiv">
              <xsl:value-of select="'Initial Metadata'"/>
            </div>
            <div class="sublevel" id="initialMetadata">
              <xsl:apply-templates select="/cml:cml/cml:metadataList[position()=1]"/>
            </div><br/>

            <br/><div onclick="js:togglemenu(&quot;inputParams&quot;)" class="divisionTitle clickableDiv">
              <xsl:value-of select="'Input Parameters'"/>
            </div>
            <div class="sublevel" id="inputParams">
              <xsl:apply-templates select="/cml:cml/cml:parameterList"/>
            <!--   <xsl:apply-templates select="/cml:cml/cml:parameterList[position()=1]"/> -->
            </div><br/>

            <br/><div onclick="js:togglemenu(&quot;initialState&quot;)" class="divisionTitle clickableDiv">
              <xsl:value-of select="'Input State of System'"/>
            </div>
            <div class="sublevel" id="initialState">
              <xsl:apply-templates select="/cml:cml/cml:module[@title='Initial System']" mode="noTitle"/>
            </div><br/>

            <br/><div onclick="js:togglemenu(&quot;mainBody&quot;)" class="divisionTitle clickableDiv">
              <xsl:value-of select="'Main Body of Simulation'"/>
            </div>
            <div class="sublevel" id="mainBody">
              <xsl:apply-templates select="/cml:cml/cml:module[(@title!='Initial System' and @title!='Finalization') or not(@title)]"/>
            </div><br/>

            <br/><div onclick="js:togglemenu(&quot;finalState&quot;)" class="divisionTitle clickableDiv">
              <xsl:value-of select="'Final State of System'"/>
            </div>
            <div class="sublevel" id="finalState">
              <xsl:apply-templates select="/cml:cml/cml:module[@title='Finalization']" mode="noTitle"/>
            </div><br/>

            <br/>
            <div onclick="js:togglemenu(&quot;summaryInfo&quot;)" class="divisionTitle clickableDiv">
              <xsl:text>Summary Information</xsl:text>
            </div>
            <div class="sublevel" id="summaryInfo">
              <xsl:call-template name="summary"/>
	    </div>
            <br/>
            <hr/>
          </div>
        </div>

<!-- Generate dictionary of document -->
        <div id="dictdisplay">
          <div class="innerDict">
            <xsl:call-template name="addDict"/>
          </div>
        </div>
<!-- -->

        <div id="foot">
          <i>Created by Toby White, Jon Wakelin,  &amp; Richard Bruin </i>
        </div>

      </body>
    </html>

  </xsl:template>

  <xsl:template name="top.level.section">
    <xsl:param name="uid"/>
    <xsl:param name="title"/>
    <xsl:param name="templates"/>
  </xsl:template>

  <xsl:template name="css-style">
    <xsl:text>
      <![CDATA[
        html       {
                     height:100%;
                     max-height:100%;
                     padding:0;
                     margin:0;
                     border:0;
                     background:#fff;
                     overflow: hidden;
                   }
        body       {
                     font-family: serif;
                     background: #ffffff;
                     height:100%;
                     max-height:100%;
                     overflow:hidden;
                     padding:0;
                     margin:0;
                     border:0;
                   }
        table      { text-align: center; 
		     border-collapse: collapse; 
		     }
	table.prop { 
	  	     text-align: right; 
	             border-collapse: collapse; 
	             border-left: hidden; 
		     border-right: hidden;
		     border-top: 1px solid Gray; 
		     border-bottom: 1px solid Gray; 
		     }
        table.structure { background: #ffffff; }

        .step       { 
                      border: 1px solid Gray;
                    }
        th.step     {
                      background: #aa2222;
                    }
        td.step     {
                      font-family: monospace;
                      background: #cc9999;
                    }
        td.stepnum { background: #ffffff; ; }

        .coords { border: 1px solid Gray;}

	.graph     {
                     text-align: left;
                   }
	
	th        { font-weight: bold; }
	td        { padding-left: 7px; padding-right: 7px;}
	.bigTitle 
                  {
                    color: #ffffff; 
                    background: Navy;    
                    font-weight: bold; 
                    margin: 0px; 
                    padding: 2px;
                    font-size: xx-large;
                  }
	.divisionTitle {
                  }
        .listTitle
                  {
                    font-weight: 900;
                    font-size: x-large;
                    margin-top: 2.5ex;
                    margin-bottom: 2.5ex;
                  }
	.clickable { 
                    text-decoration: underline;
                    color: #ffffff; 
                    background: #4682B4; 
                    cursor: pointer; 
                   }
	.eigen    { text-align: right; padding-left: 7px; padding-right: 7px; }
	.band     { vertical-align: text-top; }
	.toplevel { display: block; font-weight: 400; margin-bottom: 0; }
        .clickableDiv {color: #ffffff;
                    background: #4682B4;
                    font-weight: bold;
                    font-size: x-large;
                    border-top-width: 0px;
                    border-left-width: 0px;
                    border-right-width: 5px;
                    border-bottom-width: 5px;
                    border-color: #7dB7FF;
                    border-style: solid;
                    }
        .clickableDiv:hover {
                    color: #9999ff; 
                    }
        .moduletitle {
                    padding: 5px;
                    margin-top: 10px;
                    margin-bottom: 10px;
                     }
        .steptitle   {
                    padding: 5px;
                    margin-top: 10px;
                    margin-bottom: 10px;
                     }
        .switch      { color: #ffffff;
                       background: #4682B4;
                       font-weight: bold;
                       cursor: pointer;
                       display: inline;
                       font-size: medium; }
	.sublevel { display: none; font-weight: normal; margin-left: 20px; margin-top: 0; line-height: 14px; }
        .paramname {color: #0000ff; }
        .paramvalue {color: #ff0000; }
        #head        {
                       position:absolute; margin:0; top:0; left:0; display:block; width:100%; height:50px; z-index:5; color:#fff; background: Navy;
                     }
        #foot        {
                       position:absolute; margin:0; bottom:0; left:0; display:block; width:100%; height:25px; background:rgb(233,238,242); font-size:0.8em; z-index:5; text-align:right; color:rgb(157,78,84);
                     }
        #maindisplay {
                       position:absolute;
                       left:0;
                       top:50px;
                       bottom:25px;
                       z-index: 4;
                       width:80%;
                       overflow:auto;
                     }
        #dictdisplay {
                       position:absolute;
                       left:80%;
                       top:50px;
                       bottom:25px;
                       z-index: 4;
                       width:20%;
                       overflow:auto;
                     }
        * html #maindisplay, * html #dictdisplay {
                       height:100%;
                       top:0;
                       bottom:0;
                       border-top:50px solid #fff;
                       border-bottom:25px solid #fff;}
        .innerMain  {
                       display:block;
                       padding:0 10px 10px 10px;
                    }
        .innerDict {
                       display:block;
                       padding:0 10px 10px 10px;
                       padding-bottom:300%;
                    }

        .dictEntry  { 
                       font-family: sans-serif;
                       font-weight: bold;
                       font-size: medium;
                    }
        .dictDefinition { 
                       font-family: serif;
                       font-weight: normal;
                       font-size: small; 
                         }
        .dictDescription { 
                       font-family: serif;
                       font-weight: normal;
                       font-size: small; 
                       font-style: italic;
                         }

      ]]>
    </xsl:text>
  </xsl:template>

  <xsl:template name="mainJavascript">
    <xsl:text>
      //<![CDATA[
      function togglemenu(submenu) { 
        if (document.getElementById(submenu).style.display == "none") {
          document.getElementById(submenu).style.display = "block";
        }
        else {
          document.getElementById(submenu).style.display = "none";
         }
      }

      function toggleButton(button, submenu) { 
        if (document.getElementById(submenu).style.display == "none") {
          document.getElementById(submenu).style.display = "block";
          button.setAttribute('value', 'Hide');
        }
        else {
          document.getElementById(submenu).style.display = "none";
          button.setAttribute('value', 'Show');
         }
      }

      function toggleJmol(sz, inputNode, thisId, parentId) {
        // Grab object node to be created.
        var appNode = document.getElementById(parentId);

        if (appNode.hasChildNodes()) {
          var newAppNode = document.createElementNS('http://www.w3.org/1999/xhtml','object');
          newAppNode.setAttribute('style', "display:none;")
          newAppNode.setAttribute('id', parentId);
          var newMessage = 'Activate Jmol viewer';
        }
        else {
          var newAppNode = jmolXAppletNodeId(sz, thisId, "background white", nameSuffix=thisId);
          newAppNode.setAttribute('id', parentId);
          var newMessage = 'Deactivate Jmol viewer';
        }
        appNode.parentNode.replaceChild(newAppNode, appNode);
        inputNode.setAttribute('value', newMessage);
      }

      //]]>
    </xsl:text>
  </xsl:template>

</xsl:stylesheet>
EOF
cat > $TMPXSLTDIR/formula.xsl << "EOF"
<xsl:stylesheet 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  version="1.0">

  <xsl:template match="formula">
    <P/>
    <H3>Formula</H3>
    <xsl:call-template name="format.form">
      <xsl:with-param name="formula" select="normalize-space(.)"/>
    </xsl:call-template>
  </xsl:template>
  

  <xsl:template name="format.form">
    <xsl:param name="formula"/>
    <xsl:if test="not($formula = '')">
      <xsl:variable name="substring" select="substring-before($formula,' ')"/>
      <xsl:variable name="remainder" select="substring-after($formula,' ')"/>
      <!-- Is variable a number or a string? -->
      <xsl:choose>
        <xsl:when test="string(number($substring)) = 'NaN'">      
          <xsl:value-of select="$substring"/>
        </xsl:when>
        <xsl:when test="string(number($substring)) != 'NaN' and $substring != 1">
          <SUB><xsl:value-of select="$substring"/></SUB>
        </xsl:when>
      </xsl:choose>
      <!-- on final iteration this will be processed instead -->
      <xsl:if test="substring-after($formula,' ') = ''">
        <xsl:choose>
        <xsl:when test="string(number($formula)) = 'NaN'">      
          <xsl:value-of select="$formula"/>
        </xsl:when>
        <xsl:when test="string(number($formula)) != 'NaN' and $formula != 1">
          <SUB><xsl:value-of select="$formula"/></SUB>
        </xsl:when>
      </xsl:choose>
      </xsl:if>
      <!-- Recurse -->
      <xsl:call-template name="format.form">
        <xsl:with-param name="formula" select="$remainder"/>
      </xsl:call-template>
    </xsl:if>
  </xsl:template>
  
  </xsl:stylesheet>
  
EOF
cat > $TMPXSLTDIR/graph_bits.xsl << "EOF"
<?xml version="1.0" encoding="UTF-8" ?>
<xsl:stylesheet version="1.0"
	xmlns="http://www.uszla.me.uk/xsl/1.0/graph"
        xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        xmlns:cml="http://www.xml-cml.org/schema"
	xmlns:g="http://www.uszla.me.uk/xsl/1.0/graph"
        xmlns:exsl="http://exslt.org/common"
        extension-element-prefixes="exsl"
        >

 <xsl:template name="drawGraphOf">
    <xsl:param name="subTree" select="/cml:cml"/>
    <xsl:param name="stepType"/>
    <xsl:param name="propertyName"/>
    <xsl:param name="title" select="$propertyName"/>
    <xsl:param name="xAxisTitle" select="'Step'"/>
    <xsl:param name="yAxisTitle" select="''"/>
    <xsl:variable name="pointList">
      <g:pointList>
        <xsl:for-each select="$subTree/cml:module[@dictRef=$stepType]">
          <xsl:variable name="x" select="@serial"/>
          <xsl:variable name="y" select="cml:propertyList/cml:property[@dictRef=$propertyName]/cml:scalar"/>
          <g:point x="{$x}" y="{$y}"/>
        </xsl:for-each>
      </g:pointList>
    </xsl:variable>
    <xsl:call-template name="drawGraph">
      <xsl:with-param name="title" select="$title"/>
      <xsl:with-param name="xAxisTitle" select="$xAxisTitle"/>
      <xsl:with-param name="yAxisTitle" select="$yAxisTitle"/>
      <xsl:with-param name="pointSet" select="exsl:node-set($pointList)"/>
    </xsl:call-template>
  </xsl:template>


  <xsl:template name="selectNestedGraphNodes">
    <xsl:param name="nodes"/>
    <xsl:param name="propertyName"/>
    <g:pointList>
      <!-- for each step, if the property exists, then add its value to the pointList -->
      <xsl:for-each select="$nodes">
        <xsl:if test="cml:propertyList/cml:property[@dictRef=$propertyName]">
          <xsl:variable name="x">
	    <xsl:choose>
	      <xsl:when test="@serial">
	        <xsl:value-of select="@serial"/>
	      </xsl:when>
	      <xsl:otherwise>
	        <xsl:value-of select="position()"/>
	      </xsl:otherwise>
	    </xsl:choose>
	  </xsl:variable>
          <xsl:variable name="y" select="cml:propertyList/cml:property[@dictRef=$propertyName]/cml:scalar"/>
          <g:point x="{$x}" y="{$y}"/>
	</xsl:if>
      </xsl:for-each>
    </g:pointList>
  </xsl:template> 

  <xsl:template name="selectRDFPoints">
    <!-- FIXME subject to change as we refine RDF XML format - this is bloody fragile -->
    <xsl:param name="nodes"/>
    <g:pointList>
      <xsl:for-each select="$nodes">
        <xsl:if test="@title='grid'">
          <xsl:variable name="pos" select="position()"/>
          <xsl:variable name="x" select="cml:scalar/text()"/>
          <xsl:variable name="y" select="../cml:property[position() = ($pos + 1)]/cml:scalar/text()"/>
          <g:point x="{$x}" y="{$y}"/>
	</xsl:if>
      </xsl:for-each>
    </g:pointList>
  </xsl:template>

  <xsl:template name="selectPointsFromNodes">
    <xsl:param name="nodes"/>
    <xsl:param name="propertyNames"/>
    <g:pointList>
      <!-- for each step, if the property exists, then add its value to the pointList -->
      <xsl:for-each select="$nodes">
        <xsl:variable name="x">
          <xsl:choose>
	    <xsl:when test="@serial">
	      <xsl:value-of select="@serial"/>
	    </xsl:when>
	    <xsl:otherwise>
	      <xsl:value-of select="position()"/>
	    </xsl:otherwise>
	  </xsl:choose>
	</xsl:variable>
        <xsl:variable name="here" select="."/>
        <xsl:for-each select="$propertyNames">
          <xsl:variable name="propertyName" select="."/>
          <g:group dictRef="{$propertyName}">
            <xsl:if test="$here/cml:propertyList/cml:property[@dictRef=$propertyName]">
              <xsl:variable name="y" select="$here/cml:propertyList/cml:property[@dictRef=$propertyName]/cml:scalar"/>
              <g:point x="{$x}" y="{$y}"/>
	    </xsl:if>
	  </g:group>
	</xsl:for-each>
      </xsl:for-each>
    </g:pointList>
  </xsl:template> 

  <xsl:template name="selectedPointsFromList">
    <xsl:param name="pointList"/>
    <xsl:param name="dictRef"/>
    <g:pointList>
      <xsl:for-each select="$pointList/g:pointList/g:group[@dictRef=$dictRef]">
        <xsl:copy-of select="g:point"/>
      </xsl:for-each>
    </g:pointList>
  </xsl:template>

</xsl:stylesheet>
EOF
cat > $TMPXSLTDIR/graph_produce.xsl << "EOF"
<?xml version="1.0" encoding="UTF-8"?>

<xsl:stylesheet version="1.0"
        xmlns:cml="http://www.xml-cml.org/schema"
        xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        xmlns:g="http://www.uszla.me.uk/xsl/1.0/graph"
        >

<!-- Chunker, for multiple document output support -->
<xsl:import href="chunker.xsl"/>
<xsl:import href="toby_graph.xsl"/>
<xsl:import href="graphfuncs.xsl"/>

<xsl:output method="xml" encoding="utf-8" indent="yes"/>

<xsl:param name="graphTitle" select="default"/>
<xsl:param name="xAxisTitle" select="default"/>
<xsl:param name="yAxisTitle" select="default"/>

<!-- MAIN TEMPLATE -->
  <xsl:template match="/">
    <xsl:apply-templates select="*"/>
  </xsl:template>

  <xsl:template match="g:graphSet">

    <xsl:call-template name="drawGraph">
      <xsl:with-param name="graphTitle" select="$graphTitle"/>
      <xsl:with-param name="xAxisTitle" select="$xAxisTitle"/>
      <xsl:with-param name="yAxisTitle" select="$yAxisTitle"/>
      <xsl:with-param name="pointSet" select="."/>
    </xsl:call-template>
  </xsl:template>

</xsl:stylesheet>
EOF
cat > $TMPXSLTDIR/graphfuncs.xsl << "EOF"
<?xml version="1.0" encoding="UTF-8" ?>
<xsl:stylesheet
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	xmlns:func="http://exslt.org/functions"
	xmlns:exsl="http://exslt.org/common"
        xmlns:tohw="http://www.uszla.me.uk/xsl/1.0/functions"
        xmlns:tohw_="http://www.uszla.me.uk/xsl/1.0/functions"
        xmlns:g="http://www.uszla.me.uk/xsl/1.0/graph"
        extension-element-prefixes="func exsl tohw"
	version="1.0">

<!--    <func:function name="tohw:min">
      <xsl:param name="values"/>
      <xsl:param name="current" select="$values[1]"/>
      <xsl:if test="count($values) = 0">
        <xsl:message terminate="yes">
tohw:min requires more than zero values
        </xsl:message>
      </xsl:if>
      <xsl:variable name="newcurrent">
	<xsl:choose>
	  <xsl:when test="$values[1] &lt; $current">
	    <xsl:value-of select="$values[1]"/>
	  </xsl:when>
	  <xsl:otherwise>
	    <xsl:value-of select="$current"/>
	  </xsl:otherwise>
	</xsl:choose>
      </xsl:variable>
      <func:result>
	<xsl:choose>
	  <xsl:when test="count($values) = 1">
	    <xsl:value-of select="$newcurrent"/>
	  </xsl:when>
	  <xsl:otherwise>
	    <xsl:value-of select="tohw:min($values[position()!=1], $newcurrent)"/>
	  </xsl:otherwise>
	</xsl:choose>
      </func:result>
    </func:function>

    <func:function name="tohw:max">
      <xsl:param name="values"/>
      <xsl:param name="current" select="$values[1]"/>
      <xsl:if test="count($values) = 0">
        <xsl:message terminate="yes">
tohw:max requires more than zero values
        </xsl:message>
      </xsl:if>
      <xsl:variable name="newcurrent">
	<xsl:choose>
	  <xsl:when test="$values[1] &gt; $current">
	    <xsl:value-of select="$values[1]"/>
	  </xsl:when>
	  <xsl:otherwise>
	    <xsl:value-of select="$current"/>
	  </xsl:otherwise>
	</xsl:choose>
      </xsl:variable>
      <func:result>
	<xsl:choose>
	  <xsl:when test="count($values) = 1">
	    <xsl:value-of select="$newcurrent"/>
	  </xsl:when>
	  <xsl:otherwise>
	    <xsl:value-of select="tohw:max($values[position()!=1], $newcurrent)"/>
	  </xsl:otherwise>
	</xsl:choose>
      </func:result>
    </func:function>
-->	

  <func:function name="tohw:intpow">
    <xsl:param name="x"/>
    <xsl:param name="y"/>
    <xsl:if test="$y != floor(number($y))">
      <xsl:message terminate="yes">
tohw:intpow requires an integer power
      </xsl:message>
    </xsl:if>
    <xsl:choose>
      <xsl:when test="$y = 0">
	<func:result select="1"/>
      </xsl:when>
      <xsl:when test="$y = 1">
	<func:result select="$x"/>
      </xsl:when>
      <xsl:when test="$y &lt; 0">
	<func:result select="1 div tohw:intpow($x,-1 * $y)"/>
      </xsl:when>
      <xsl:otherwise>
	<func:result select="$x * tohw:intpow($x, $y - 1)"/>
      </xsl:otherwise>
    </xsl:choose>
  </func:function>

  <func:function name="tohw:floorlog10">
    <xsl:param name="x"/>
    <xsl:variable name="stringLog">
      <xsl:choose>
	<xsl:when test="$x = 0.0">
          0	  
	</xsl:when>
	<xsl:when test="contains(string($x), 'e')">
	  <!-- non-conformant xpath implementation -->
	  <xsl:value-of select="substring-after(string($x),'e')"/>
	</xsl:when>
	<xsl:when test="contains(string($x),'E')">
	  <!-- non-conformant xpath implementation -->
	  <xsl:value-of select="substring-after(string($x),'E')"/>
	</xsl:when>
	<xsl:when test="$x &gt;= 1">
	  <xsl:choose>
	    <xsl:when test="contains($x, '.')">
	      <xsl:value-of select="string-length(substring-before(string($x),'.'))"/>
	    </xsl:when>
	    <xsl:otherwise>
	      <xsl:value-of select="string-length($x)"/>
	    </xsl:otherwise>
	  </xsl:choose>
	</xsl:when>
	<xsl:when test="$x &lt;= -1">
	  <xsl:choose>
	    <xsl:when test="contains($x, '.')">
	      <xsl:value-of select="string-length(substring-before(string($x),'.')) - 1"/>
	    </xsl:when>
	    <xsl:otherwise>
	      <xsl:value-of select="string-length($x) - 1"/>
	    </xsl:otherwise>
	  </xsl:choose>
	</xsl:when>
	<xsl:otherwise>
	  <xsl:value-of select="-1 * tohw:floorlog10(1 div $x)"/>
	</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="contains($stringLog,'+')">
	<func:result select="number(substring-after($stringLog,'+'))-1"/>
      </xsl:when>
      <xsl:otherwise>
	<func:result select="number($stringLog)-1"/>
      </xsl:otherwise>
    </xsl:choose>
  </func:function>

  <xsl:template name="tohw:addUp">
    <!-- Generate an (inclusive) list of 0*$size, 1*$size, ..., $endIter*$size -->
    <xsl:param name="size"/>
    <xsl:param name="iterator" select="0"/>
    <xsl:param name="endIter"/>
    <number value="{$iterator * $size}"/>
    <xsl:if test="$iterator &lt; $endIter">
      <xsl:call-template name="tohw:addUp">
	<xsl:with-param name="size" select="$size"/>
	<xsl:with-param name="iterator" select="$iterator+1"/>
	<xsl:with-param name="endIter" select="$endIter"/>
      </xsl:call-template>
    </xsl:if>
  </xsl:template>

  <func:function name="tohw:launderFP">
    <xsl:param name="x"/>
    <xsl:variable name="n">
      <xsl:choose>
	<xsl:when test="contains(string($x), 'e')">
	  <xsl:value-of select="number(substring-before(string($x),'e'))"/>
	</xsl:when>
	<xsl:when test="contains(string($x),'E')">
	  <xsl:value-of select="number(substring-before(string($x),'E'))"/>
	</xsl:when>
	<xsl:otherwise>
	  <xsl:value-of select="number($x)"/>
	</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="p1">
      <xsl:choose>
	<xsl:when test="contains(string($x), 'e')">
	  <xsl:value-of select="substring-after(string($x),'e')"/>
	</xsl:when>
	<xsl:when test="contains(string($x),'E')">
	  <xsl:value-of select="substring-after(string($x),'E')"/>
	</xsl:when>
	<xsl:otherwise>
	  <xsl:value-of select="0"/>
	</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="p">
      <xsl:choose>
	<xsl:when test="contains($p1,'+')">
	  <xsl:value-of select="number(substring-after($p1,'+'))"/>
	</xsl:when>
	<xsl:otherwise>
	  <xsl:value-of select="number($p1)"/>
	</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <func:result select="number($n)*tohw:intpow(10,$p)"/>
  </func:function>

  <xsl:template name="g:tickValues">
    <xsl:param name="minV"/>
    <xsl:param name="maxV"/>
    <xsl:param name="numTicks" select="4"/>
    <xsl:variable name="range" select="$maxV - $minV"/>
    <xsl:variable name="sectionSize" select="$range div ($numTicks + 1)"/>
    <xsl:variable name="ticks">
      <xsl:call-template name="tohw:addUp">
	<xsl:with-param name="size" select="$sectionSize"/>
	<xsl:with-param name="endIter" select="$numTicks+1"/>
      </xsl:call-template>
    </xsl:variable>
    <g:tickList>
      <xsl:for-each select="exsl:node-set($ticks)/number/@value">
	<g:tick value="{. + $minV}"/>
      </xsl:for-each>
    </g:tickList>
  </xsl:template>

  <xsl:template name="launderTree">
    <xsl:param name="tree"/>
    <xsl:for-each select="$tree/node()">
      <xsl:choose>
	<xsl:when test="local-name()='point' and namespace-uri()='http://www.uszla.me.uk/xsl/1.0/graph'">
	  <g:point x="{tohw:launderFP(@x)}" y="{tohw:launderFP(@y)}"/>
	</xsl:when>
	<xsl:when test="count(./child::node()) &gt; 0">
	  <xsl:element namespace="{namespace-uri()}" name="{local-name()}">
	    <xsl:call-template name="launderTree">
	      <xsl:with-param name="tree" select="."/>
	    </xsl:call-template>
	  </xsl:element>
	</xsl:when>
	<xsl:otherwise>
	  <xsl:copy-of select="."/>
	</xsl:otherwise>
      </xsl:choose>
    </xsl:for-each>
  </xsl:template>

</xsl:stylesheet>
EOF
cat > $TMPXSLTDIR/lattice.xsl << "EOF"
<!--===================== LATTICE =========================-->

<xsl:stylesheet version="1.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        xmlns:cml="http://www.xml-cml.org/schema"
        xmlns:str="http://exslt.org/strings"
        xmlns="http://www.w3.org/1999/xhtml"
        extension-element-prefixes="str"
        >

<!-- cmlCore:crystal -->  
  <xsl:template match="cml:crystal">
    <p/>
    <div class="listTitle">Lattice Parameters: <xsl:value-of select="@title"/></div>
    <xsl:variable name="lenUnits">
      <xsl:choose>
        <xsl:when test="cml:scalar">Ang</xsl:when>
        <xsl:when test="cml:cellParameter">
          <xsl:choose>
            <xsl:when test="cml:cellParameter[@parameterType='length']/@units">
              <xsl:value-of select="cml:cellParameter[@parameterType='length']/@units"/>
            </xsl:when>
            <xsl:otherwise>Ang</xsl:otherwise>
          </xsl:choose>
        </xsl:when>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="angUnits">
      <xsl:choose>
        <xsl:when test="cml:scalar">degrees</xsl:when>
        <xsl:when test="cml:cellParameter">
          <xsl:choose>
            <xsl:when test="cml:cellParameter[@parameterType='angle']/@units">
              <xsl:value-of select="cml:cellParameter[@parameterType='angle']/@units"/>
            </xsl:when>
            <xsl:otherwise>degrees</xsl:otherwise>
          </xsl:choose>
        </xsl:when>
      </xsl:choose>
    </xsl:variable>
               
    <table>
      <tr> 
        <th colspan="3">Lattice Modules (<xsl:value-of select="$lenUnits"/>)</th>
      </tr>
      <tr>
        <xsl:choose>
          <xsl:when test="cml:scalar">
            <td><xsl:value-of select="cml:scalar[position() = 1]"/></td>
            <td><xsl:value-of select="cml:scalar[position() = 2]"/></td>
            <td><xsl:value-of select="cml:scalar[position() = 3]"/></td>
          </xsl:when>
          <xsl:when test="cml:cellParameter">
            <xsl:variable name="cellParameters" value="str:tokenize(cml:cellParameter[@parameterType='length']/text())"/>
            <td><xsl:value-of select="str:tokenize(cml:cellParameter[@parameterType='length'])[1]"/></td>       
            <td><xsl:value-of select="str:tokenize(cml:cellParameter[@parameterType='length'])[2]"/></td>       
            <td><xsl:value-of select="str:tokenize(cml:cellParameter[@parameterType='length'])[3]"/></td>       
          </xsl:when>
        </xsl:choose>
      </tr>  
      <tr>
        <th colspan="3">Lattice Angles (<xsl:value-of select="$angUnits"/>)</th>
      </tr>
      <tr>
        <xsl:choose>
          <xsl:when test="cml:scalar">
            <td><xsl:value-of select="cml:scalar[position() = 4]"/></td>
            <td><xsl:value-of select="cml:scalar[position() = 5]"/></td>
            <td><xsl:value-of select="cml:scalar[position() = 6]"/></td>
          </xsl:when>
          <xsl:when test="cml:cellParameter">
            <td><xsl:value-of select="str:tokenize(cml:cellParameter[@parameterType='angle'])[1]"/></td>       
            <td><xsl:value-of select="str:tokenize(cml:cellParameter[@parameterType='angle'])[2]"/></td>       
            <td><xsl:value-of select="str:tokenize(cml:cellParameter[@parameterType='angle'])[3]"/></td>       
          </xsl:when>
        </xsl:choose>
      </tr>
    </table>
  </xsl:template>

  <xsl:template match="cml:lattice">
    <p/>
    <div class="listTitle">Lattice Parameters</div>
    <table>
      <tr><th colspan="3">Lattice Vectors</th></tr>
      <xsl:for-each select="cml:latticeVector">
        <tr>
          <td><xsl:value-of select="str:tokenize(text())[1]"/></td>
          <td><xsl:value-of select="str:tokenize(text())[2]"/></td>
          <td><xsl:value-of select="str:tokenize(text())[3]"/></td>
        </tr>
      </xsl:for-each>
    </table>
  </xsl:template>
  
</xsl:stylesheet>
EOF
cat > $TMPXSLTDIR/matrix.xsl << "EOF"
<xsl:stylesheet version="1.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        xmlns:cml="http://www.xml-cml.org/schema"
        xmlns="http://www.w3.org/1999/xhtml"
	>

<!-- TOHW rewrite this tou just use str:tokenize -->

  <xsl:template match="cml:matrix">
    <xsl:param name="rows">
      <xsl:value-of select="@rows"/>
    </xsl:param>
    <xsl:param name="cols">
      <xsl:value-of select="@columns"/>
    </xsl:param>
    <xsl:variable name="dataString" select="concat(normalize-space(.),' ')"/>
    <table class="prop">
      <tr>
	<th colspan="{$cols}">
	  <xsl:call-template name="get.dictionary.reference.html">
            <xsl:with-param name="dictRef" select="@dictRef"/>
            <xsl:with-param name="value" select="@value"/>
          </xsl:call-template>
	  <xsl:text> (</xsl:text>
	  <xsl:value-of select="@units"/>
	  <xsl:text>) </xsl:text>
  	</th>
      </tr>

      <xsl:call-template name="rows-for-loop">
        <xsl:with-param name="i" select="1"/>
        <xsl:with-param name="increment" select="1"/>
        <xsl:with-param name="testValue" select="$rows"/>
        <xsl:with-param name="innerTestValue" select="$cols"/>
        <xsl:with-param name="outputString" select="$dataString"/>
      </xsl:call-template>
    </table>
  </xsl:template>


  <xsl:template name="rows-for-loop">
    <!--This template handles the rows of matrices-->
    <xsl:param name="i" select="0"/>
    <xsl:param name="increment" select="1"/>
    <xsl:param name="testValue"/>
    <xsl:param name="innerTestValue"/>
    <xsl:param name="outputString" select="''"/>
    <xsl:variable name="testPassed">
      <xsl:choose>
	<xsl:when test="$i &lt;= $testValue">
	  <xsl:text>true</xsl:text>
	</xsl:when>
	<xsl:otherwise>
	  <xsl:text>false</xsl:text>
	</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="continueString">
      <xsl:call-template name="modify-string-for-loop">
	<xsl:with-param name="i" select="1"/>
	<xsl:with-param name="string" select="$outputString"/>
	<xsl:with-param name="colsNumber" select="$innerTestValue"/>
      </xsl:call-template>
    </xsl:variable>

    <xsl:if test="$testPassed = 'true'">
      <tr>
	<xsl:call-template name="cols-for-loop">
	  <xsl:with-param name="i" select="1"/>
	  <xsl:with-param name="increment" select="1"/>
	  <xsl:with-param name="testValue" select="$innerTestValue"/>
	  <xsl:with-param name="outputString" select="$outputString"/>
	</xsl:call-template>
      </tr>

      <xsl:call-template name="rows-for-loop">
	<xsl:with-param name="i" select="$i + $increment"/>
	<xsl:with-param name="increment" select="$increment"/>
	<xsl:with-param name="testValue" select="$testValue"/>
	<xsl:with-param name="innerTestValue" select="$innerTestValue"/>
	<xsl:with-param name="outputString" select="$continueString"/>
      </xsl:call-template>
    </xsl:if>
    
  </xsl:template>

  <xsl:template name="cols-for-loop">
    <!-- This template handles the columns of the matrices -->
    <xsl:param name="i" select="0"/>
    <xsl:param name="increment" select="1"/>
    <xsl:param name="testValue"/>
    <xsl:param name="outputString" select="''"/>
    <xsl:variable name="testPassed">
      <xsl:choose>
	<xsl:when test="$i &lt;= $testValue">
	  <xsl:text>true</xsl:text>
	</xsl:when>
	<xsl:otherwise>
	  <xsl:text>false</xsl:text>
	</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>

    <xsl:if test="$testPassed = 'true'">
      <td>
	<xsl:value-of select="format-number(substring-before($outputString, ' '), '0.0000')"/>
      </td>

      <xsl:call-template name="cols-for-loop">
	<xsl:with-param name="i" select="$i + $increment"/>
	<xsl:with-param name="increment" select="$increment"/>
	<xsl:with-param name="testValue" select="$testValue"/>
	<xsl:with-param name="outputString" select="substring-after($outputString, ' ')"/>
      </xsl:call-template>
    </xsl:if>
    
  </xsl:template>

  <xsl:template name="modify-string-for-loop">
    <!--
      This template modifies the string passed to it, to remove the parts
      which are removed as part of the inner for loop i.e. the rows-for-loop template
    -->
    <xsl:param name="i" select="1"/>
    <xsl:param name="string" select="''"/>
    <xsl:param name="colsNumber" select="0"/>
    <xsl:variable name="testPassed">
      <xsl:choose>
	<xsl:when test="$i &lt;= $colsNumber">
	  <xsl:text>true</xsl:text>
	</xsl:when>
	<xsl:otherwise>
	  <xsl:text>false</xsl:text>
	</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>

    <xsl:if test="$testPassed = 'true'">
      <xsl:call-template name="modify-string-for-loop">
	<xsl:with-param name="i" select="$i + 1"/>
	<xsl:with-param name="colsNumber" select="$colsNumber"/>
	<xsl:with-param name="string" select="substring-after($string, ' ')"/>
      </xsl:call-template>
    </xsl:if>
    <xsl:if test="not($testPassed = 'true')">
      <xsl:value-of select="$string"/>
    </xsl:if>

  </xsl:template>

</xsl:stylesheet>
EOF
cat > $TMPXSLTDIR/metadata.xsl << "EOF"
<?xml version="1.0" encoding="UTF-8" ?>

<!--===================== METADATA =========================-->

<xsl:stylesheet version="1.0" 
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        xmlns="http://www.w3.org/1999/xhtml"
        xmlns:cml="http://www.xml-cml.org/schema"
        >

  <xsl:template match="cml:metadataList">
    <xsl:if test="count(cml:metadata)&gt;0">
      <ul class="metadata"><xsl:apply-templates select="cml:metadata"/></ul>
    </xsl:if>
    <hr/>
  </xsl:template>

  <xsl:template match="cml:metadata">  
   <xsl:choose>
    <xsl:when test="parent::cml:metadataList">
     <li>
      <xsl:value-of select="@name"/><xsl:text>: </xsl:text>
      <i><xsl:value-of select="@content"/></i>
     </li>
    </xsl:when>
    <xsl:otherwise>
     <ul><li>
      <xsl:value-of select="@name"/><xsl:text>: </xsl:text>
      <i><xsl:value-of select="@content"/></i>
     </li></ul>
    </xsl:otherwise>
   </xsl:choose>
  </xsl:template>
</xsl:stylesheet>
EOF
cat > $TMPXSLTDIR/module.xsl << "EOF"
<?xml version="1.0" encoding="utf-8"?>

<xsl:stylesheet version="1.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        xmlns:cml="http://www.xml-cml.org/schema"
        xmlns="http://www.w3.org/1999/xhtml"
	>

  <xsl:import href="toby_graph.xsl"/>

  <xsl:template match="cml:module" mode="noTitle">
    <xsl:variable name="uid" select="generate-id()"/>
    <div>
      <xsl:apply-templates select="*"/>
    </div>
  </xsl:template>

  <xsl:template match="cml:module">
    <xsl:variable name="uid" select="generate-id()"/>
    <xsl:choose>
      <xsl:when test="@role='step'">
         <xsl:call-template name="step"/>
      </xsl:when>
      <xsl:otherwise>
         <div>
           <div onclick="js:togglemenu(&quot;{$uid}&quot;)" class="moduletitle clickableDiv">
             <xsl:value-of select="@title"/>
           </div>
         </div>
         <div class="sublevel" id="{$uid}">
           <xsl:apply-templates select="*"/>
         </div>
       </xsl:otherwise>
     </xsl:choose>
  </xsl:template>

<!-- Match Any Step -->
  <xsl:template name="step">
    <xsl:variable name="uid" select="generate-id()"/>
    <xsl:variable name="num">
      <xsl:choose>
        <xsl:when test="@serial">
	  <xsl:value-of select="@serial"/>
	</xsl:when>
        <xsl:otherwise>
	  <xsl:value-of select="count(preceding-sibling::cml:module[@role='step']) + 1"/>
	</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:choose>
      <!-- If we are in a child step; ie we have direct parent steps;
           then we don't want (at this stage, anyway) to output lots of
           crap. Instead, a quick table (and maybe graph) of everything
           that's going on is fine. -->
      <xsl:when test="ancestor::cml:module[@role='step']">
         <xsl:variable name="count">
          <xsl:number count="cml:module[@role='step']"/>
        </xsl:variable>
	<!-- only output the table on the first step. -->
        <xsl:if test="$count=1">
	  <xsl:variable name="thisId" select="generate-id()"/>
          <div class="listTitle"><xsl:value-of select="@dictRef"/> Steps</div>
          <div>Table <input type="button" value="Show" onclick="js:toggleButton(this, &quot;{$thisId}&quot;)"/></div>
          <table class="step" style="display:none;" id="{$thisId}">
            <tr class="step"><th class="step"><xsl:value-of select="@dictRef"/> Step</th>
	      <xsl:for-each select="cml:propertyList/cml:property">
	        <xsl:variable name="thisDictRef" select="@dictRef"/>
		<!-- Only output properties that are there for every SCF step. Should really build up a list here .-->
                <xsl:if test="count(../../../cml:module[@role='step']/cml:propertyList/cml:property[@dictRef=$thisDictRef]) = (count(../../../cml:module[@role='step'])-1)">
	          <th class="step">
	            <xsl:call-template name="get.dictionary.reference.html">
                      <xsl:with-param name="dictRef" select="@dictRef"/>
                      <xsl:with-param name="title" select="@title"/>
                    </xsl:call-template>
	            <xsl:text>(</xsl:text>
	            <xsl:value-of select="cml:scalar/@units"/>
	            <xsl:text>)</xsl:text>
	          </th>
		</xsl:if>
	      </xsl:for-each>
	    </tr>
            <xsl:for-each select="../cml:module[@role='step']">
	      <!-- do not output last step for siesta SCF FIXME -->
	      <xsl:if test="position() != last()">
              <tr class="step">
	        <td class="stepnum">
                  <xsl:choose>
                    <xsl:when test="@serial">
                      <xsl:value-of select="@serial"/>
                    </xsl:when>
                    <xsl:otherwise>
                      <xsl:value-of select ="position()"/>
                    </xsl:otherwise>
                  </xsl:choose>
                </td>
                <xsl:for-each select="cml:propertyList/cml:property/cml:scalar"> 
	          <xsl:variable name="thisDictRef" select="../@dictRef"/>
                  <xsl:if test="count(../../../../cml:module[@role='step']/cml:propertyList/cml:property[@dictRef=$thisDictRef]) = (count(../../../../cml:module[@role='step'])-1)">
	            <td class="step"><xsl:value-of select="."/></td>
		  </xsl:if>
                </xsl:for-each>
	      </tr>
	      </xsl:if>
            </xsl:for-each>
          </table>
        </xsl:if>
      </xsl:when> <!-- child step -->
      <xsl:otherwise>
        <xsl:if test="(count(preceding-sibling::cml:module[@role='step'])+1) mod $stepinterval = 0">
        <div>
          <div onclick="js:togglemenu(&quot;{$uid}&quot;)" class="steptitle clickableDiv">
            <a><xsl:value-of select="@dictRef"/> Step <xsl:value-of select="$num"/></a>
          </div>
        </div>
        <div class="sublevel" id="{$uid}">
          <xsl:apply-templates select="*"/>
	  <!-- here put graphs of substeps ... -->
	  <!-- <xsl:if test="@dictRef = 'CG' or dictRef = 'MD'">
	    <xsl:variable name="SCFnodeSet1">
	      <xsl:call-template name="selectNestedGraphNodes">
		<xsl:with-param name="nodes" select="./cml:module[@role='step']"/>
		<xsl:with-param name="stepType" select="'SCF'"/>
		<xsl:with-param name="propertyName" select="'siesta:Eharrs'"/>
	      </xsl:call-template>
	    </xsl:variable>
	    <xsl:variable name="SCFgraph1">
	      <xsl:call-template name="drawGraph">
		<xsl:with-param name="graphTitle" select="'Harris energy'"/>
		<xsl:with-param name="xAxisTitle" select="'SCF Step'"/>
		<xsl:with-param name="yAxisTitle" select="'Energy / eV'"/>
		<xsl:with-param name="pointSet" select="exsl:node-set($SCFnodeSet1)"/>
	      </xsl:call-template>
	    </xsl:variable>
	    <div><xsl:copy-of select="$SCFgraph1"/></div>
	  </xsl:if> -->
        </div>
        </xsl:if>
      </xsl:otherwise>
    </xsl:choose> 
  </xsl:template>
  
</xsl:stylesheet>
EOF
cat > $TMPXSLTDIR/moduleWithGraphs.xsl << "EOF"
<?xml version="1.0" encoding="UTF-8" ?>

<xsl:stylesheet version="1.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        xmlns:cml="http://www.xml-cml.org/schema"
        xmlns="http://www.w3.org/1999/xhtml"
	>

<xsl:import href="toby_graph.xsl"/>
<xsl:import href="siestagraphs.xsl"/>


  <xsl:template match="cml:module">
    <xsl:variable name="uid" select="generate-id()"/>
    <xsl:choose>
      <xsl:when test="@role='step'">
         <xsl:call-template name="step"/>
      </xsl:when>
      <xsl:otherwise>
         <hr />
         <div>
           <div onclick="js:togglemenu(&quot;{$uid}&quot;)" class="moduletitle">
             <xsl:value-of select="@title"/>
           </div>
         </div>
         <div class="sublevel" id="{$uid}">
           <xsl:apply-templates select="*"/>
         </div>
         <hr />
       </xsl:otherwise>
     </xsl:choose>
  </xsl:template>

<!-- Match Any Step -->
  <xsl:template name="step">
    <xsl:variable name="uid" select="generate-id()"/>
    <xsl:variable name="num">
      <xsl:choose>
        <xsl:when test="@serial">
	  <xsl:value-of select="@serial"/>
	</xsl:when>
        <xsl:otherwise>
	  <xsl:value-of select="count(preceding-sibling::cml:module[@role='step']) + 1"/>
	</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:choose>
      <!-- For outer steps just give brief title and HR -->
      <!-- i.e when there are descendant steps          -->
      <xsl:when test="descendant::cml:module[@role='step']">
        <div>
          <div onclick="js:togglemenu(&quot;{$uid}&quot;)" class="steptitle">
            <a><xsl:value-of select="@dictRef"/> Step <xsl:value-of select="$num"/></a>
          </div>
        </div>
        <div class="sublevel" id="{$uid}">
          <xsl:apply-templates select="*"/>
	  <!-- here put graphs of substeps ... -->
	  <xsl:if test="@dictRef = 'SCF' or dictRef = 'MD'">
	    <xsl:variable name="SCFnodeSet1">
	      <xsl:call-template name="selectNestedGraphNodes">
		<xsl:with-param name="subTree" select="."/>
		<xsl:with-param name="stepType" select="'SCF'"/>
		<xsl:with-param name="propertyName" select="'siesta:Eharrs'"/>
	      </xsl:call-template>
	    </xsl:variable>
	    <xsl:variable name="SCFgraph1">
	      <xsl:call-template name="drawGraph">
		<xsl:with-param name="graphTitle" select="'Harris energy'"/>
		<xsl:with-param name="xAxisTitle" select="'SCF Step'"/>
		<xsl:with-param name="yAxisTitle" select="'Energy / eV'"/>
		<xsl:with-param name="pointSet" select="exsl:node-set($SCFnodeSet1)"/>
	      </xsl:call-template>
	    </xsl:variable>
	    <div><xsl:copy-of select="$SCFgraph1"/></div>
	  </xsl:if>
        </div>
      </xsl:when>
      <!-- For the Inner most steps only create a summary table -->
      <!-- i.e when there are NO descendant steps               -->
        <xsl:otherwise> 
        <xsl:variable name="count">
          <xsl:number count="cml:module[@role='step']"/>
        </xsl:variable>
	<!-- only output the table on the first step. -->
        <xsl:if test="$count=1">
	  <xsl:variable name="thisId" select="generate-id()"/>
          <div class="listTitle"><xsl:value-of select="@dictRef"/> Steps</div>
          <div>Table <input type="button" value="Show" onclick="js:toggleButton(this, &quot;{$thisId}&quot;)"/></div>
	      <xsl:for-each select="cml:propertyList/cml:property">
	        <xsl:variable name="thisDictRef" select="@dictRef"/>
	        <xsl:variable name="theseUnits" select="@units"/>
		<!-- Only output properties that are there for every SCF step. Should really build up a list here .-->
                <xsl:if test="count(../../../cml:module[@role='step']/cml:propertyList/cml:property[@dictRef=$thisDictRef]) = (count(../../../cml:module[@role='step'])-1)">
                  <xsl:variable name="graphNodeSet">
                    <xsl:call-template name="selectNestedGraphNodes">
                      <xsl:with-param name="stepType" select="'CG'"/>
                      <xsl:with-param name="propertyName" select="$thisDictRef"/>
                    </xsl:call-template>
                  </xsl:variable>

                  <xsl:variable name="Graph">
                    <xsl:call-template name="drawGraph">
                      <xsl:with-param name="graphTitle" select="$thisDictRef"/>
                      <xsl:with-param name="xAxisTitle" select="'Step'"/>
                      <xsl:with-param name="yAxisTitle" select="$theseUnits"/>
                      <xsl:with-param name="pointSet" select="exsl:node-set($graphNodeSet)"/>
                     </xsl:call-template>
                  </xsl:variable>
	        </xsl:if>
            </xsl:for-each>
          </table>
        </xsl:if>
      </xsl:otherwise>
    </xsl:choose> 
  </xsl:template>
  
</xsl:stylesheet>
EOF
cat > $TMPXSLTDIR/modulenew.xsl << "EOF"
<?xml version="1.0" encoding="UTF-8" ?>

<xsl:stylesheet version="1.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        xmlns:cml="http://www.xml-cml.org/schema"
        xmlns="http://www.w3.org/1999/xhtml"
	>

<xsl:import href="toby_graph.xsl"/>
<xsl:import href="siestagraphs.xsl"/>


  <xsl:template match="cml:module">
    <xsl:variable name="uid" select="generate-id()"/>
    <xsl:choose>
      <xsl:when test="@type=='step'">
         <xsl:call-template name="step"/>
      </xsl:when>
      <xsl:otherwise>
         <hr />
         <div>
           <div onclick="js:togglemenu(&quot;{$uid}&quot;)" class="moduletitle">
             <xsl:value-of select="@title"/>
           </div>
         </div>
         <div class="sublevel" id="{$uid}">
           <xsl:apply-templates select="*"/>
         </div>
         <hr />
       </xsl:otherwise>
     </xsl:choose>
  </xsl:template>

</xsl:stylesheet>
<?xml version="1.0" encoding="UTF-8" ?>

<!-- Match Any Step -->
  <xsl:template name="step">
    <xsl:variable name="uid" select="generate-id()"/>
    <xsl:variable name="num"><xsl:number count="cml:step"/></xsl:variable>
    <xsl:variable name="num">
      <xsl:choose>
        <xsl:when test="@serial">
	  <xsl:value-of select="@serial"/>
	</xsl:when>
        <xsl:otherwise>
	  <xsl:number count="parent::cml:module[@type='step']">
	</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:choose>
      <!-- For outer steps just give brief title and HR -->
      <!-- i.e when there are descendant steps          -->
      <xsl:when test="descendant::cml:module[@type='step']">
        <div>
          <div onclick="js:togglemenu(&quot;{$uid}&quot;)" class="steptitle">
            <a><xsl:value-of select="@type"/> Step <xsl:value-of select="$num"/></a>
          </div>
        </div>
        <div class="sublevel" id="{$uid}">
          <xsl:apply-templates select="*"/>
	  <!-- here put graphs of substeps ... -->
	  <xsl:if test="@type = 'SCF' or @type = 'MD'">
	    <xsl:variable name="SCFnodeSet1">
	      <xsl:call-template name="selectNestedGraphNodes">
		<xsl:with-param name="subTree" select="."/>
		<xsl:with-param name="stepType" select="'SCF'"/>
		<xsl:with-param name="propertyName" select="'siesta:Eharrs'"/>
	      </xsl:call-template>
	    </xsl:variable>
	    <xsl:variable name="SCFgraph1">
	      <xsl:call-template name="drawGraph">
		<xsl:with-param name="graphTitle" select="'Harris energy'"/>
		<xsl:with-param name="xAxisTitle" select="'SCF Step'"/>
		<xsl:with-param name="yAxisTitle" select="'Energy / eV'"/>
		<xsl:with-param name="pointSet" select="exsl:node-set($SCFnodeSet1)"/>
	      </xsl:call-template>
	    </xsl:variable>
	    <div><xsl:copy-of select="$SCFgraph1"/></div>
	  </xsl:if>
        </div>
      </xsl:when>
      <!-- For the Inner most steps only create a summary table -->
      <!-- i.e when there are NO descendant steps               -->
        <xsl:otherwise> 
        <xsl:variable name="count">
          <xsl:number count="cml:step"/>
        </xsl:variable>
        <xsl:if test="$count=1">
	  <xsl:variable name="thisId" select="generate-id()"/>
          <div class="listTitle"><xsl:value-of select="@type"/> Steps</div>
          <div>Table <input type="button" value="Show" onclick="js:toggleButton(this, &quot;{$thisId}&quot;)"/></div>
          <table class="step" style="display:none;" id="{$thisId}">
            <tr class="step"><th class="step"><xsl:value-of select="@type"/> Step</th>
	      <xsl:for-each select="cml:propertyList/cml:property">
	        <th class="step">
	          <xsl:call-template name="get.dictionary.reference.html">
                    <xsl:with-param name="dictRef" select="@dictRef"/>
                    <xsl:with-param name="title" select="@title"/>
                  </xsl:call-template>
	          <xsl:text>(</xsl:text>
	          <xsl:value-of select="cml:scalar/@units"/>
	          <xsl:text>)</xsl:text>
	        </th>
	      </xsl:for-each>
	    </tr>
            <xsl:for-each select="../cml:step">
              <tr class="step">
	        <td class="stepnum">
                  <xsl:choose>
                    <xsl:when test="@index">
                      <xsl:value-of select="@index"/>
                    </xsl:when>
                    <xsl:otherwise>
                      <xsl:value-of select ="position()"/>
                    </xsl:otherwise>
                  </xsl:choose>
                </td>
                <xsl:for-each select="cml:propertyList/cml:property/cml:scalar"> 
	          <td class="step"><xsl:value-of select="."/></td>
                </xsl:for-each>
	      </tr>
            </xsl:for-each>
          </table>
        </xsl:if>
      </xsl:otherwise>
    </xsl:choose> 
  </xsl:template>
  
</xsl:stylesheet>
EOF
cat > $TMPXSLTDIR/moduleold.xsl << "EOF"
<?xml version="1.0" encoding="UTF-8" ?>

<xsl:stylesheet version="1.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        xmlns:cml="http://www.xml-cml.org/schema"
        xmlns="http://www.w3.org/1999/xhtml"
	>

  <xsl:template match="cml:module">
    <xsl:variable name="uid" select="generate-id()"/>
    
    <hr />
    <div>
      <div onclick="js:togglemenu(&quot;{$uid}&quot;)" class="moduletitle">
        <xsl:value-of select="@title"/>
      </div>
    </div>
    <div class="sublevel" id="{$uid}">
      <xsl:apply-templates select="*"/>
    </div>
    <hr />
  </xsl:template>

</xsl:stylesheet>
EOF
cat > $TMPXSLTDIR/moduleworks.xsl << "EOF"
<?xml version="1.0" encoding="UTF-8" ?>

<xsl:stylesheet version="1.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        xmlns:cml="http://www.xml-cml.org/schema"
        xmlns="http://www.w3.org/1999/xhtml"
	>

<xsl:import href="toby_graph.xsl"/>
<xsl:import href="siestagraphs.xsl"/>


  <xsl:template match="cml:module">
    <xsl:variable name="uid" select="generate-id()"/>
    <xsl:choose>
      <xsl:when test="@role='step'">
         <xsl:call-template name="step"/>
      </xsl:when>
      <xsl:otherwise>
         <hr />
         <div>
           <div onclick="js:togglemenu(&quot;{$uid}&quot;)" class="moduletitle">
             <xsl:value-of select="@title"/>
           </div>
         </div>
         <div class="sublevel" id="{$uid}">
           <xsl:apply-templates select="*"/>
         </div>
         <hr />
       </xsl:otherwise>
     </xsl:choose>
  </xsl:template>

<!-- Match Any Step -->
  <xsl:template name="step">
    <xsl:variable name="uid" select="generate-id()"/>
    <xsl:variable name="num">
      <xsl:choose>
        <xsl:when test="@serial">
	  <xsl:value-of select="@serial"/>
	</xsl:when>
        <xsl:otherwise>
	  <xsl:value-of select="count(preceding-sibling::cml:module[@role='step']) + 1"/>
	</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:choose>
      <!-- For outer steps just give brief title and HR -->
      <!-- i.e when there are descendant steps          -->
      <xsl:when test="descendant::cml:module[@role='step']">
        <div>
          <div onclick="js:togglemenu(&quot;{$uid}&quot;)" class="steptitle">
            <a><xsl:value-of select="@dictRef"/> Step <xsl:value-of select="$num"/></a>
          </div>
        </div>
        <div class="sublevel" id="{$uid}">
          <xsl:apply-templates select="*"/>
	  <!-- here put graphs of substeps ... -->
	  <xsl:if test="@dictRef = 'SCF' or dictRef = 'MD'">
	    <xsl:variable name="SCFnodeSet1">
	      <xsl:call-template name="selectNestedGraphNodes">
		<xsl:with-param name="subTree" select="."/>
		<xsl:with-param name="stepType" select="'SCF'"/>
		<xsl:with-param name="propertyName" select="'siesta:Eharrs'"/>
	      </xsl:call-template>
	    </xsl:variable>
	    <xsl:variable name="SCFgraph1">
	      <xsl:call-template name="drawGraph">
		<xsl:with-param name="graphTitle" select="'Harris energy'"/>
		<xsl:with-param name="xAxisTitle" select="'SCF Step'"/>
		<xsl:with-param name="yAxisTitle" select="'Energy / eV'"/>
		<xsl:with-param name="pointSet" select="exsl:node-set($SCFnodeSet1)"/>
	      </xsl:call-template>
	    </xsl:variable>
	    <div><xsl:copy-of select="$SCFgraph1"/></div>
	  </xsl:if>
        </div>
      </xsl:when>
      <!-- For the Inner most steps only create a summary table -->
      <!-- i.e when there are NO descendant steps               -->
        <xsl:otherwise> 
        <xsl:variable name="count">
          <xsl:number count="cml:module[@role='step']"/>
        </xsl:variable>
	<!-- only output the table on the first step. -->
        <xsl:if test="$count=1">
	  <xsl:variable name="thisId" select="generate-id()"/>
          <div class="listTitle"><xsl:value-of select="@dictRef"/> Steps</div>
          <div>Table <input type="button" value="Show" onclick="js:toggleButton(this, &quot;{$thisId}&quot;)"/></div>
          <table class="step" style="display:none;" id="{$thisId}">
            <tr class="step"><th class="step"><xsl:value-of select="@dictRef"/> Step</th>
	      <xsl:for-each select="cml:propertyList/cml:property">
	        <xsl:variable name="thisDictRef" select="@dictRef"/>
		<!-- Only output properties that are there for every SCF step. Should really build up a list here .-->
                <xsl:if test="count(../../../cml:module[@role='step']/cml:propertyList/cml:property[@dictRef=$thisDictRef]) = (count(../../../cml:module[@role='step'])-1)">
	          <th class="step">
	            <xsl:call-template name="get.dictionary.reference.html">
                      <xsl:with-param name="dictRef" select="@dictRef"/>
                      <xsl:with-param name="title" select="@title"/>
                    </xsl:call-template>
	            <xsl:text>(</xsl:text>
	            <xsl:value-of select="cml:scalar/@units"/>
	            <xsl:text>)</xsl:text>
	          </th>
		</xsl:if>
	      </xsl:for-each>
	    </tr>
            <xsl:for-each select="../cml:module[@role='step']">
	      <!-- do not output last step for siesta SCF FIXME -->
	      <xsl:if test="position() != last()">
              <tr class="step">
	        <td class="stepnum">
                  <xsl:choose>
                    <xsl:when test="@serial">
                      <xsl:value-of select="@serial"/>
                    </xsl:when>
                    <xsl:otherwise>
                      <xsl:value-of select ="position()"/>
                    </xsl:otherwise>
                  </xsl:choose>
                </td>
                <xsl:for-each select="cml:propertyList/cml:property/cml:scalar"> 
	          <xsl:variable name="thisDictRef" select="../@dictRef"/>
                  <xsl:if test="count(../../../../cml:module[@role='step']/cml:propertyList/cml:property[@dictRef=$thisDictRef]) = (count(../../../../cml:module[@role='step'])-1)">
	            <td class="step"><xsl:value-of select="."/></td>
		  </xsl:if>
                </xsl:for-each>
	      </tr>
	      </xsl:if>
            </xsl:for-each>
          </table>
        </xsl:if>
      </xsl:otherwise>
    </xsl:choose> 
  </xsl:template>
  
</xsl:stylesheet>
EOF
cat > $TMPXSLTDIR/parameter.xsl << "EOF"
<?xml version="1.0" encoding="UTF-8" ?>

<!--===================== PARAMETERS =========================-->

<xsl:stylesheet version="1.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        xmlns:cml="http://www.xml-cml.org/schema"
        xmlns="http://www.w3.org/1999/xhtml"
	>

  <xsl:template match="cml:parameter">
    <xsl:choose>
    
    <!-- If single parameter then place in a table -->
      <xsl:when test="not(parent::cml:parameterList)">
	<p/>
        <table>
	  <tr>
	    <xsl:if test="@name"><td><xsl:value-of select="@name"/></td></xsl:if>
	    <xsl:if test="@value"><td><xsl:value-of select="@value"/></td></xsl:if>
            <xsl:if test="cml:scalar"><xsl:apply-templates select="cml:scalar"/></xsl:if>
            <xsl:if test="cml:array"><xsl:apply-templates select="cml:array"/></xsl:if>
	    <xsl:if test="cml:matrix"><xsl:apply-templates select="cml:matrix"/></xsl:if>
          </tr>
        </table>
      </xsl:when>

    <!-- If parameter list then place all properties in a single table -->

      <xsl:otherwise>
        <tr>

    <!-- The parameter name *should* be in a name attribute - I think
         sometimes it may come out in title, so we check below. That
         option will be removed later on, since FoX never does that. -->

          <td align="left" class="paramname">
            <xsl:choose>
              <xsl:when test="@name">
	        <xsl:value-of select="@name"/>
              </xsl:when>
              <xsl:when test="@title">
	        <xsl:value-of select="@title"/>
              </xsl:when>
            </xsl:choose> 
          </td>

    <!-- The parameter value *should* be in a scalar/array/matrix child.
         Sometimes it is in the value attribue though, so we check below
         That option will be removed later on since FoX never does that. -->

          <td align="right" class="paramvalue">
            <xsl:choose>
              <xsl:when test="@value">
              <!-- When it is in @value, we can't tell the datatype unless we try: -->
                <xsl:choose>
	          <xsl:when test="string(number(@value)) != 'NaN'">
	            <xsl:value-of select="format-number(@value, '0.0000')"/>
	          </xsl:when>
	          <xsl:otherwise>
	            <xsl:value-of select="@value"/>
	          </xsl:otherwise>
	        </xsl:choose>
              </xsl:when>
              <xsl:otherwise>
                <xsl:if test="cml:scalar"><xsl:apply-templates select="cml:scalar"/></xsl:if>
                <xsl:if test="cml:array"><xsl:apply-templates select="cml:array"/></xsl:if>
                <xsl:if test="cml:matrix"><xsl:apply-templates select="cml:matrix"/></xsl:if>
              </xsl:otherwise>
            </xsl:choose>
          </td>
        </tr>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
    
  <xsl:template match="cml:parameterList">
    <xsl:apply-templates select="@title"/>
    <table><xsl:apply-templates select="*"/></table>
  </xsl:template>
  
<!-- @title List -->
  <xsl:template match="@title">
    <div class="listTitle"><xsl:value-of select="."/></div>
  </xsl:template>

</xsl:stylesheet>
EOF
cat > $TMPXSLTDIR/parameterList.xsl << "EOF"
<?xml version="1.0" encoding="UTF-8" ?>

<!--===================== PARAMETER LISTS =========================-->

<xsl:stylesheet 
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        xmlns="http://www.w3.org/1999/xhtml"
        xmlns:cml="http://www.xml-cml.org/schema"
	version="1.0">

<!-- cmlComa:parameterList -->
  <xsl:template match="cml:parameterList">
    <xsl:apply-templates select="@title"/>
    <table><xsl:apply-templates select="*"/></table>
  </xsl:template>
  
<!-- @title List -->
  <xsl:template match="@title">
    <div class="listTitle"><xsl:value-of select="."/></div>
  </xsl:template>

</xsl:stylesheet>
EOF
cat > $TMPXSLTDIR/property.xsl << "EOF"
<?xml version="1.0" encoding="UTF-8" ?>

<!--===================== PROPERTIES =========================-->

<xsl:stylesheet version="1.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        xmlns:cml="http://www.xml-cml.org/schema"
        xmlns="http://www.w3.org/1999/xhtml"
	>


  <xsl:template match="cml:property">
    <xsl:choose>
      <xsl:when test="not(parent::cml:propertyList)">
        <br/>
	<table><tr><xsl:call-template name="addProperty"/></tr></table>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="addProperty"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
  
  
  <xsl:template name="addProperty">
   <td align="left">
     <b>
       <xsl:call-template name="get.dictionary.reference.html">
         <xsl:with-param name="dictRef" select="@dictRef"/>
         <xsl:with-param name="title" select="@title"/>
       </xsl:call-template>
     </b>
   </td>
   <xsl:choose>
    <!-- Must special-case scalar because units are treated differently -->
    <xsl:when test="cml:scalar">
     <xsl:apply-templates select="cml:scalar"/>
    </xsl:when>
    <xsl:otherwise>
     <td align="right">
      <xsl:choose>
       <xsl:when test="cml:array">
        <xsl:apply-templates select="cml:array"/>
       </xsl:when>
       <xsl:when test="cml:matrix">
        <xsl:apply-templates select="cml:matrix"/>
       </xsl:when>
       <xsl:when test="cml:table">
        <xsl:apply-templates select="cml:table"/>
       </xsl:when>
      </xsl:choose>
     </td>
     <td align="left"><xsl:call-template name="add.units"/><p><br/></p></td>
    </xsl:otherwise>
   </xsl:choose>
  </xsl:template>

  <xsl:template match="cml:propertyList">
   <xsl:apply-templates select="@title"/>
   <table class="propertyList">
    <xsl:for-each select="*">
     <tr><xsl:apply-templates select="."/></tr>
    </xsl:for-each>
   </table>
  </xsl:template>
  
<!-- @title List -->
  <xsl:template match="@title">
    <div class="listTitle"><xsl:value-of select="."/></div>
  </xsl:template>

</xsl:stylesheet>
EOF
cat > $TMPXSLTDIR/propertyList.xsl << "EOF"
<?xml version="1.0" encoding="UTF-8" ?>

<!--===================== PROPERTY LISTS =========================-->

<xsl:stylesheet version="1.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        xmlns:cml="http://www.xml-cml.org/schema"
        xmlns="http://www.w3.org/1999/xhtml"
        >

<!-- cmlComa:propertyList -->
  <xsl:template match="cml:propertyList">
   <xsl:apply-templates select="@title"/>
   <table class="propertyList">
    <xsl:for-each select="*">
     <tr><xsl:apply-templates select="."/></tr>
    </xsl:for-each>
   </table>
  </xsl:template>
  
<!-- @title List -->
  <xsl:template match="@title">
    <div class="listTitle"><xsl:value-of select="."/></div>
  </xsl:template>

</xsl:stylesheet>
EOF
cat > $TMPXSLTDIR/rdf.xsl << "EOF"
<?xml version="1.0" encoding="UTF-8" ?>

<!--===================== RDF graphs =========================-->

<xsl:stylesheet version="1.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        xmlns:cml="http://www.xml-cml.org/schema"
        xmlns="http://www.w3.org/1999/xhtml"
        xmlns:exsl="http://exslt.org/common"
        extension-element-prefixes="exsl"
        >

  <xsl:template match="cml:propertyList[@dictRef='dl_poly:rdf']">
   <div>
     <p><xsl:text> RDF profiles </xsl:text></p>
     <table>
       <xsl:for-each select="cml:propertyList[@title='rdf pair']">

         <xsl:variable name="RDFtitle">
           <xsl:value-of select="cml:property[@title='atom type 1']"/>
           <xsl:text>-</xsl:text>
           <xsl:value-of select="cml:property[@title='atom type 2']"/>
         </xsl:variable>
 
         <!-- Retrieve all numbers: -->
         <xsl:variable name="gridpoints" select="cml:propertyList[@title='rdf table']/cml:property"/>
         <xsl:variable name="RDFGraphPoints">
           <xsl:call-template name="selectRDFPoints">
             <xsl:with-param name="nodes" select="exsl:node-set($gridpoints)"/>
           </xsl:call-template>
         </xsl:variable> 
         <!-- draw the graph -->
         <xsl:variable name="graph">
           <xsl:call-template name="drawGraph">
             <xsl:with-param name="graphTitle" select="$RDFtitle"/>
             <xsl:with-param name="xAxisTitle" select="r"/>
             <xsl:with-param name="yAxisTitle" select="Occupation"/>
             <xsl:with-param name="pointSet" select="exsl:node-set($RDFGraphPoints)"/>
           </xsl:call-template> 
         </xsl:variable>
         <div>
           <!-- output the graph -->
           <xsl:variable name="graphId" select="generate-id()"/>
           <tr class="graph">
             <td class="graph"><xsl:value-of select="$RDFtitle"/>:</td>
             <td class="graph"><input type="button" value="Show" onclick="js:toggleButton(this, &quot;{$graphId}&quot;)"/></td><br/>
             <div style="display:none;" id="{$graphId}"><xsl:copy-of select="$graph"/></div>
           </tr>
         </div>
       </xsl:for-each>
     </table>
   </div>
 </xsl:template>

  
</xsl:stylesheet>
EOF
cat > $TMPXSLTDIR/rich-averageVolume.xsl << "EOF"
<?xml version="1.0" encoding="UTF-8" ?>
<xsl:stylesheet version="1.0"
   xmlns:cml="http://www.xml-cml.org/schema"
   xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   xmlns:tohw="http://www.uszla.me.uk/xsl/1.0/functions"
   xmlns:g="http://www.uszla.me.uk/xsl/1.0/graph"
   extension-element-prefixes="tohw"
>
<xsl:output method="xml"/>

<xsl:param name="fileList"/>

<xsl:template match="/">
  <g:graphSet>
    <g:pointList>
      <xsl:apply-templates select="*"/>
    </g:pointList>
  </g:graphSet>
</xsl:template>

<xsl:template match="file">
  <xsl:element name="point" namespace="http://www.uszla.me.uk/xsl/1.0/graph">
    <xsl:attribute name="x">
      <xsl:value-of select="document(.)//cml:parameterList[@title='control parameters']/cml:parameter[@dictRef='dl_poly:pressure']/cml:scalar"/>
    </xsl:attribute>
    <xsl:attribute name="y">
<!--      <xsl:value-of select="sum(document(.)//cml:step/cml:propertyList[@title='instantaneous']/cml:property[@dictRef='dl_poly:volume']/cml:scalar) div count(document(.)//cml:step/cml:propertyList[@title='instantaneous']/cml:property[@dictRef='dl_poly:volume']/cml:scalar)"/>-->
	<xsl:value-of select="document(.)//cml:propertyList[@title='final averages']/cml:propertyList[@title='general properties']/cml:property[@title='volume']/cml:scalar"/>
    </xsl:attribute>
  </xsl:element>
</xsl:template>


</xsl:stylesheet>

EOF
cat > $TMPXSLTDIR/scalar.xsl << "EOF"
<?xml version="1.0" encoding="UTF-8" ?>

<!--===================== SCALAR =========================-->

<xsl:stylesheet version="1.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        xmlns:cml="http://www.xml-cml.org/schema"
        xmlns="http://www.w3.org/1999/xhtml"
        >

<!-- scalar List-->
  <xsl:template match="cml:scalar">
    <xsl:if test="@dictRef">
      <br/> 
      <td align="left">
        <b>
          <xsl:call-template name="get.dictionary.reference.html">
            <xsl:with-param name="dictRef" select="@dictRef"/>
            <xsl:with-param name="title" select="@title"/>
          </xsl:call-template>
        </b>
      </td>
    </xsl:if>

   <xsl:variable name="printableOutput">
     <!-- look for dataType attribute to see how to format -->
     <!-- except actually at the moment, we format the same
          way regardless -->
     <xsl:choose>
       <xsl:when test="@dataType">
         <xsl:value-of select="text()"/>
       </xsl:when>
       <xsl:otherwise>
         <xsl:value-of select="text()"/>
       </xsl:otherwise>
     </xsl:choose>
   </xsl:variable>
    
    <xsl:choose>
      <xsl:when test="parent::cml:parameter">
        <td align="right" class="paramvalue"><xsl:value-of select="$printableOutput"/></td>
      </xsl:when>
      <xsl:otherwise>
      	<td align="right">
	  <xsl:choose>
	    <xsl:when test="ceiling(.) = floor(.) and not(contains(.,'.'))">
	      <xsl:value-of select="."/>
	    </xsl:when>
	    <xsl:when test="string(number(.)) != 'NaN'">
	      <xsl:value-of select="format-number(., '0.0000')"/>
	    </xsl:when>
	    <xsl:otherwise>
	      <xsl:value-of select="."/>
            </xsl:otherwise>
          </xsl:choose>	        
	</td>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:if test="@units">
      <td align="left"><xsl:text> </xsl:text><i><xsl:value-of select="@units"/></i></td>
    </xsl:if>
  </xsl:template>

</xsl:stylesheet>
EOF
cat > $TMPXSLTDIR/siestagraphs.xsl << "EOF"
<?xml version="1.0" encoding="UTF-8" ?>
<xsl:stylesheet version="1.0"
        xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        xmlns:html="http://www.w3.org/1999/xhtml"
        xmlns:cml="http://www.xml-cml.org/schema"
        xmlns:exsl="http://exslt.org/common"
        extension-element-prefixes="exsl"
        >

  <xsl:import href="toby_graph.xsl"/>
  <xsl:import href="graph_bits.xsl"/>

  <xsl:template name="siestaGraphs">
    <xsl:variable name="typeOfRun" select="/cml:cml/cml:parameterList/cml:parameter[@name='MD.TypeOfRun']/@value"/>
    <xsl:choose>
      <xsl:when test="$typeOfRun = 'CG'">
	<xsl:variable name="CGnodeSet1">
	  <xsl:call-template name="selectNestedGraphNodes">
	    <xsl:with-param name="stepType" select="'CG'"/>
	    <xsl:with-param name="propertyName" select="'siesta:E_KS'"/>
	  </xsl:call-template>
	</xsl:variable>

	<xsl:variable name="CGgraph1">
	  <xsl:call-template name="drawGraph">
	    <xsl:with-param name="graphTitle" select="'Kohn-Sham energy'"/>
	    <xsl:with-param name="xAxisTitle" select="'Step'"/>
	    <xsl:with-param name="yAxisTitle" select="'Energy / eV'"/>
	    <xsl:with-param name="pointSet" select="exsl:node-set($CGnodeSet1)"/>
	  </xsl:call-template>
	</xsl:variable>
	
	<xsl:variable name="CGnodeSet2">
	  <xsl:call-template name="selectNestedGraphNodes">
	    <xsl:with-param name="stepType" select="'CG'"/>
	    <xsl:with-param name="propertyName" select="'siesta:cfmax'"/>
	  </xsl:call-template>
	</xsl:variable>
	
	<xsl:variable name="CGgraph2">
	  <xsl:call-template name="drawGraph">
	    <xsl:with-param name="graphTitle" select="'Maximum constrained force'"/>
	    <xsl:with-param name="xAxisTitle" select="'Step'"/>
	    <xsl:with-param name="yAxisTitle" select="'Newtons'"/>
	    <xsl:with-param name="pointSet" select="exsl:node-set($CGnodeSet2)"/>
	  </xsl:call-template>
	</xsl:variable>
	
	<!-- <html:object type="image/svg+xml" width="600" height="500">
	     <xsl:copy-of select="$CGgraph"/>
	     </html:object> -->
	
	<html:div><xsl:copy-of select="$CGgraph1"/></html:div>
	<html:div><xsl:copy-of select="$CGgraph2"/></html:div>

      </xsl:when>
      <!-- <xsl:when test="$typeOfRun = 'Verlet'">
	<html:object data="graph.svg" type="image/svg+xml" width="300" height="300">
	  <xsl:call-template name="drawGraphOf">
	    <xsl:with-param name="stepType" select="'MD'"/>
	    <xsl:with-param name="propertyName" select="'siesta:E_KS'"/>
	    <xsl:with-param name="title" select="'Kohn-Sham energy'"/>
	    <xsl:with-param name="xAxisTitle" select="'Step'"/>
	    <xsl:with-param name="yAxisTitle" select="'Energy / eV'"/>
	  </xsl:call-template>
	</html:object>
      </xsl:when> -->
    </xsl:choose> 
  </xsl:template>

</xsl:stylesheet>
EOF
cat > $TMPXSLTDIR/step.xsl << "EOF"
<?xml version="1.0" encoding="UTF-8" ?>

<!--===================== STEP =========================-->

<xsl:stylesheet version="1.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        xmlns:cml="http://www.xml-cml.org/schema"
        xmlns="http://www.w3.org/1999/xhtml"
        >

<xsl:import href="toby_graph.xsl"/>
<xsl:import href="siestagraphs.xsl"/>

<!-- Match Any Step -->
  <xsl:template match="//cml:step">
    <xsl:variable name="uid" select="generate-id()"/>
    <xsl:variable name="num"><xsl:number count="cml:step"/></xsl:variable>
    <xsl:choose>
      <!-- For outer steps just give brief title and HR -->
      <!-- i.e when there are descendant steps          -->
      <xsl:when test="descendant::cml:step">
        <div>
          <div onclick="js:togglemenu(&quot;{$uid}&quot;)" class="steptitle">
            <a><xsl:value-of select="@type"/> Step <xsl:value-of select="$num"/></a>
          </div>
        </div>
        <div class="sublevel" id="{$uid}">
          <xsl:apply-templates select="*"/>
	  <!-- here put graphs of substeps ... -->
	  <xsl:if test="@type = 'SCF' or @type = 'MD'">
	    <xsl:variable name="SCFnodeSet1">
	      <xsl:call-template name="selectNestedGraphNodes">
		<xsl:with-param name="subTree" select="."/>
		<xsl:with-param name="stepType" select="'SCF'"/>
		<xsl:with-param name="propertyName" select="'siesta:Eharrs'"/>
	      </xsl:call-template>
	    </xsl:variable>
	    <xsl:variable name="SCFgraph1">
	      <xsl:call-template name="drawGraph">
		<xsl:with-param name="graphTitle" select="'Harris energy'"/>
		<xsl:with-param name="xAxisTitle" select="'SCF Step'"/>
		<xsl:with-param name="yAxisTitle" select="'Energy / eV'"/>
		<xsl:with-param name="pointSet" select="exsl:node-set($SCFnodeSet1)"/>
	      </xsl:call-template>
	    </xsl:variable>
	    <div><xsl:copy-of select="$SCFgraph1"/></div>
	  </xsl:if>
        </div>
      </xsl:when>
      <!-- For the Inner most steps only create a summary table -->
      <!-- i.e when there are NO descendant steps               -->
        <xsl:otherwise> 
        <xsl:variable name="count">
          <xsl:number count="cml:step"/>
        </xsl:variable>
        <xsl:if test="$count=1">
	  <xsl:variable name="thisId" select="generate-id()"/>
          <div class="listTitle"><xsl:value-of select="@type"/> Steps</div>
          <div>Table <input type="button" value="Show" onclick="js:toggleButton(this, &quot;{$thisId}&quot;)"/></div>
          <table class="step" style="display:none;" id="{$thisId}">
            <tr class="step"><th class="step"><xsl:value-of select="@type"/> Step</th>
	      <xsl:for-each select="cml:propertyList/cml:property">
	        <th class="step">
	          <xsl:call-template name="get.dictionary.reference.html">
                    <xsl:with-param name="dictRef" select="@dictRef"/>
                    <xsl:with-param name="title" select="@title"/>
                  </xsl:call-template>
	          <xsl:text>(</xsl:text>
	          <xsl:value-of select="cml:scalar/@units"/>
	          <xsl:text>)</xsl:text>
	        </th>
	      </xsl:for-each>
	    </tr>
            <xsl:for-each select="../cml:step">
              <tr class="step">
	        <td class="stepnum">
                  <xsl:choose>
                    <xsl:when test="@index">
                      <xsl:value-of select="@index"/>
                    </xsl:when>
                    <xsl:otherwise>
                      <xsl:value-of select ="position()"/>
                    </xsl:otherwise>
                  </xsl:choose>
                </td>
                <xsl:for-each select="cml:propertyList/cml:property/cml:scalar"> 
	          <td class="step"><xsl:value-of select="."/></td>
                </xsl:for-each>
	      </tr>
            </xsl:for-each>
          </table>
        </xsl:if>
      </xsl:otherwise>
    </xsl:choose> 
  </xsl:template>
  
</xsl:stylesheet>
EOF
cat > $TMPXSLTDIR/structure.xsl << "EOF"
<?xml version="1.0" encoding="UTF-8" ?>

<!--===================== STRUCTURES =========================-->

<xsl:stylesheet version="1.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        xmlns:str="http://exslt.org/strings" 
        xmlns:cml="http://www.xml-cml.org/schema"
        xmlns="http://www.w3.org/1999/xhtml"
        exclude-result-prefixes="xsl str"
        extension-element-prefixes="str">

  <!-- cmlCore:molecule -->
  <xsl:template match="cml:molecule">
    <xsl:param name="natoms" select="count(cml:atomArray/cml:atom)"/>
    <xsl:param name="num">  
      <xsl:number level="any"/>
    </xsl:param>
<!--    <xsl:param name="moleculePosition">
      <xsl:value-of select="count(ancestor::cml:step[//cml:molecule]/preceding-sibling::cml:step[//cml:molecule])+1"/>
    </xsl:param> -->

    <!-- Output an image of the crystal structure for the first step
	with image coordinates -->
<!--     <xsl:if test="$moleculePosition = 1">
    </xsl:if> -->

    <div class="listTitle">Structure</div>
    <xsl:call-template name="makejmol">
      <xsl:with-param name="natoms" select="$natoms"/>
    </xsl:call-template>

    <br /><br />
    <!-- COORDINATES -->
    <xsl:call-template name="coords">
      <xsl:with-param name="num" select="$num"/>
    </xsl:call-template>
    
  </xsl:template>
  
  <xsl:template name="makejmol">
    <xsl:param name="natoms"/>
    <xsl:param name="num" select="generate-id()"/>
    <xsl:param name="parentId" select="concat('parent_', $num)"/>
    <xsl:param name="thisId" select="concat('mol_', $num)"/>
    <xsl:param name="height">
      <xsl:choose>
        <xsl:when test="$natoms &lt; 10">
          <xsl:value-of select="200"/>
        </xsl:when>
        <xsl:when test="$natoms &gt; 10 and $natoms &lt; 50">
	    <xsl:value-of select="400"/>
        </xsl:when>
        <xsl:when test="$natoms &gt; 50">
	    <xsl:value-of select="600"/>
        </xsl:when>
      </xsl:choose>
    </xsl:param>
    <xsl:param name="width">
      <xsl:choose>
        <xsl:when test="$natoms &lt; 10">
          <xsl:value-of select="200"/>
        </xsl:when>
        <xsl:when test="$natoms &gt; 10 and $natoms &lt; 50">
	    <xsl:value-of select="400"/>
        </xsl:when>
        <xsl:when test="$natoms &gt; 50">
	    <xsl:value-of select="600"/>
        </xsl:when>
      </xsl:choose>
    </xsl:param>
    <div>
      <div style="display:none;">
        <cml:cml id="{$thisId}">
          <cml:molecule>
            <!-- <xsl:if test="not(cml:crystal)">
              <xsl:if test="count(../cml:crystal) = 1">
                <xsl:copy-of select="../cml:crystal"/>
              </xsl:if>
            </xsl:if> -->
            <xsl:copy-of select="./cml:atomArray"/>
          </cml:molecule>
        </cml:cml>
      </div>
      <input type="button" value="Activate Jmol viewer" onclick="javascript:toggleJmol([{$width},{$height}], this, &quot;{$thisId}&quot;, &quot;{$parentId}&quot;)"/>
      <object id="{$parentId}" style="display:none;"/>
    </div>
  </xsl:template>


  <!-- JMOL MOVIE -->
  <xsl:template name="movie">
    <xsl:param name="natoms" select="count(cml:molecule[position()=1]/cml:atomArray/cml:atom)"/>
    <xsl:param name="height">
      <xsl:choose>
        <xsl:when test="$natoms &lt; 10">
          <xsl:value-of select="200"/>
        </xsl:when>
        <xsl:when test="$natoms &gt; 10 and $natoms &lt; 50">
	    <xsl:value-of select="400"/>
        </xsl:when>
        <xsl:when test="$natoms &gt; 50">
	    <xsl:value-of select="600"/>
        </xsl:when>
      </xsl:choose>
    </xsl:param>
    <xsl:param name="width">
      <xsl:choose>
        <xsl:when test="$natoms &lt; 10">
          <xsl:value-of select="200"/>
        </xsl:when>
        <xsl:when test="$natoms &gt; 10 and $natoms &lt; 50">
	    <xsl:value-of select="400"/>
        </xsl:when>
        <xsl:when test="$natoms &gt; 50">
	    <xsl:value-of select="600"/>
        </xsl:when>
      </xsl:choose>
    </xsl:param>
    <div class="listTitle">Animation</div>
    <div>
      <div style="display:none;">
        <cml:cml id="animation">
          <cml:list convention="JMOL-ANIMATION">
            <xsl:for-each select="//cml:molecule">
              <cml:molecule id="FRAME{position()}">
	        <!-- <xsl:if test="not(cml:crystal)">
	          <xsl:if test="count(../cml:crystal) = 1">
                    <xsl:copy-of select="../cml:crystal"/>
                  </xsl:if>
	        </xsl:if> -->
                <xsl:copy-of select="./cml:atomArray"/>
	      </cml:molecule>
            </xsl:for-each>
          </cml:list>
        </cml:cml>
      </div>
      <input type="button" value="Activate Jmol viewer" onclick="javascript:toggleJmol([{$width},{$height}], this, &quot;animation&quot;, &quot;parentAnim&quot;)"/>
      <object id="parentAnim" style="display:none;"/>
   </div>
  </xsl:template>

 
  <!-- COORDINATES FILE -->
  <xsl:template name="coords">  
    <xsl:param name="num"/>
    <xsl:variable name="id" select="concat('pos_', $num)"/>
    <!--         <title><xsl:value-of select="$file"/></title> -->
    <xsl:variable name="uid" select="generate-id()"/>
    <input type="button" value="View coordinates" onclick="js:togglemenu(&quot;{$uid}&quot;)"/>
    <div class="sublevel" id="{$uid}">
      <table class="coords">
        <tr class="coords">
          <th class="coords">Atom #</th>
          <xsl:if test="cml:atomArray/cml:atom/@elementType"><th class="coords">Element</th></xsl:if>
          <xsl:if test="cml:atomArray/cml:atom/@x3"><th class="coords">x / &#x00C5;ng</th></xsl:if>
          <xsl:if test="cml:atomArray/cml:atom/@y3"><th class="coords">y / &#x00C5;ng</th></xsl:if>
          <xsl:if test="cml:atomArray/cml:atom/@z3"><th class="coords">z / &#x00C5;ng</th></xsl:if>
          <xsl:if test="cml:atomArray/cml:atom/@xyz3">
            <th class="coords">x / &#x00C5;ng</th>
	    <th class="coords">y / &#x00C5;ng</th>
	    <th class="coords">z / &#x00C5;ng</th>
          </xsl:if>
          <xsl:if test="cml:atomArray/cml:atom/@xFract"><th class="coords">x (Frac)</th></xsl:if>
          <xsl:if test="cml:atomArray/cml:atom/@yFract"><th class="coords">y (Frac)</th></xsl:if>
          <xsl:if test="cml:atomArray/cml:atom/@zFract"><th class="coords">z (Frac)</th></xsl:if>
          <xsl:if test="cml:atomArray/cml:atom/@xyzFract">
            <th class="coords">x (Frac)</th>
            <th class="coords">y (Frac)</th>
	    <th class="coords">z (Frac)</th>
          </xsl:if>
          <xsl:if test="cml:atomArray/cml:atom/@occupancy"><th class="coords">Occ.</th></xsl:if>
          <xsl:if test="cml:atomArray/cml:atom/@formalCharge"><th class="coords">Charge</th></xsl:if>
        </tr>
        <xsl:for-each select="cml:atomArray/cml:atom">
	  <tr class="coords">
	    <td class="coords"><xsl:value-of select="position()"/></td>
            <xsl:if test="@elementType"><td class="coords"><xsl:value-of select="@elementType"/></td></xsl:if>
	    <xsl:if test="@x3"><td class="coords"><xsl:value-of select="format-number(@x3, '###0.000')"/></td></xsl:if>
            <xsl:if test="@y3"><td class="coords"><xsl:value-of select="format-number(@y3, '###0.000')"/></td></xsl:if>
            <xsl:if test="@z3"><td class="coords"><xsl:value-of select="format-number(@z3, '###0.000')"/></td></xsl:if>
	    <xsl:if test="@xyz3">
	      <xsl:for-each select="str:tokenize(@xyz3,' ')">
	        <!--  <TD><xsl:value-of select="format-number(., '###0.000')"/></TD> -->
                <td class="coords"><xsl:value-of select="."/> </td>
	      </xsl:for-each>
	    </xsl:if>
	    <xsl:if test="@xFract"><td class="coords"><xsl:value-of select="format-number(@xFract, '###0.000')"/></td></xsl:if>
	    <xsl:if test="@yFract"><td class="coords"><xsl:value-of select="format-number(@yFract, '###0.000')"/></td></xsl:if>
	    <xsl:if test="@zFract"><td class="coords"><xsl:value-of select="format-number(@zFract, '###0.000')"/></td></xsl:if>
	    <xsl:if test="@xyzFract">
	      <xsl:for-each select="str:tokenize(@xyz3,' ')">
	        <!-- <TD><xsl:value-of select="format-number(., '###0.000')"/></TD> -->
                <td class="coords"><xsl:value-of select="."/> </td>
	      </xsl:for-each>
	    </xsl:if>
	    <xsl:if test="@formalCharge"><td class="coords"><xsl:value-of select="format-number(@formalCharge, ' ##;-##')"/></td></xsl:if>
  	  </tr>
        </xsl:for-each>
      </table>
    </div>
    <script type="text/javascript">
      //
      var divnode=document.getElementById(&quot;<xsl:value-of select="$id"/>&quot;)
      //
    </script>
  </xsl:template>

</xsl:stylesheet>
EOF
cat > $TMPXSLTDIR/summary.xsl << "EOF"
<?xml version="1.0" encoding="UTF-8" ?>
<xsl:stylesheet version="1.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	xmlns:html="http://www.w3.org/1999/xhtml"
        xmlns:func="http://exslt.org/functions"
        xmlns:exsl="http://exslt.org/common"
        xmlns:cml="http://www.xml-cml.org/schema"
        extension-element-prefixes="func exsl"
        >

<xsl:import href="toby_graph.xsl"/>
<xsl:import href="summarygraphs.xsl"/>
 
<!-- Summary information at end of html output. 
     Including graphs of relevant properties 
     and animation of simulation progression -->

  <xsl:template name="summary">

    <xsl:call-template name="summaryGraphs"/>
    
    <!-- Finally, add animation -->
    <xsl:if test="count(//cml:molecule) &gt; 0">
      <xsl:call-template name="movie"/>
    </xsl:if>    
    
  </xsl:template>
  

</xsl:stylesheet>
EOF
cat > $TMPXSLTDIR/summarygraphs.xsl << "EOF"
<?xml version="1.0" encoding="UTF-8" ?>
<xsl:stylesheet version="1.0"
        xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        xmlns="http://www.w3.org/1999/xhtml"
        xmlns:exsl="http://exslt.org/common"
        xmlns:cml="http://www.xml-cml.org/schema"
        extension-element-prefixes="exsl"
        >

  <xsl:import href="graph_bits.xsl"/>
  
<!-- 
This is generally the most time-consuming part of the XSLT process
for a DLPOLY run, because there are lots of properties output all at
lots of timesteps. This could be ameliorated if DLPOLY output fewer
properties.

Particularly what takes time is the selectNestedGraphNodes template,
which runs through the file, pulling out values at each step for 
each property we will graph. It is conceivable that it might be 
faster to run through the file once, pull out all properties in
which we are interested, put that in a great big node-set, and then
comb through the in-memory smaller node-set for each graph. This
is what summaryGraphs2 below does. However, on testing, this is
actually slower.
-->

  <xsl:template name="summaryGraphs">
    <div class="listTitle">Graphs by timestep</div>
    <table class="graph">
    <xsl:variable name="steps" select="/cml:cml/cml:module[@role='step']"/>

    <!-- find all properties that are output in both first and last steps: -->
    <xsl:variable name="properties">
      <xsl:for-each select="$steps[position()=1]/cml:propertyList/cml:property">
        <xsl:variable name="dictRef" select="@dictRef"/>
        <xsl:if test="$steps[position()=last()]/cml:propertyList/cml:property[@dictRef=$dictRef]">
          <xsl:copy-of select="."/>
	</xsl:if>
      </xsl:for-each>
    </xsl:variable>

    <!-- for each of said properties ... -->
    <xsl:for-each select="exsl:node-set($properties)/cml:property">
      <!-- check dataType -->
      <xsl:if test="cml:scalar/@dataType = 'xsd:integer' or cml:scalar/@dataType = 'xsd:decimal' or cml:scalar/@dataType = 'xsd:float' or cml:scalar/@dataType = 'xsd:double'">
        <xsl:variable name="units" select="cml:scalar/@units"/>
        <!-- lookup units somewhere -->
        <xsl:variable name="dictName">
          <xsl:call-template name="get.dictionary.reference.html">
            <xsl:with-param name="dictRef" select="@dictRef"/>
            <xsl:with-param name="title" select="@title"/>
          </xsl:call-template>
        </xsl:variable>
        <!-- pull out all the x & y values -->
        <xsl:variable name="graphNodeSet">
          <xsl:call-template name="selectNestedGraphNodes">
            <xsl:with-param name="nodes" select="exsl:node-set($steps)"/>
            <xsl:with-param name="propertyName" select="@dictRef"/>
          </xsl:call-template>
        </xsl:variable>
        <!-- draw the graph -->
        <xsl:variable name="graph">
          <xsl:call-template name="drawGraph">
            <xsl:with-param name="graphTitle" select="$dictName"/>
            <xsl:with-param name="xAxisTitle" select="'Step'"/>
            <xsl:with-param name="yAxisTitle" select="$units"/>
            <xsl:with-param name="pointSet" select="exsl:node-set($graphNodeSet)"/>
          </xsl:call-template> 
        </xsl:variable>
        <!-- output the graph -->
        <xsl:variable name="graphId" select="generate-id()"/>
        <tr class="graph">
          <td class="graph"><xsl:value-of select="$dictName"/>:</td>
          <td class="graph"><input type="button" value="Show" onclick="js:toggleButton(this, &quot;{$graphId}&quot;)"/></td><br/>
          <div style="display:none;" id="{$graphId}"><xsl:copy-of select="$graph"/></div>
        </tr>
      </xsl:if>
    </xsl:for-each>
  </table>
  </xsl:template>

  <xsl:template name="summaryGraphs2">
    <div class="listTitle">Graphs by timestep</div>
    <table class="graph">
    <xsl:variable name="steps" select="/cml:cml/cml:module[@role='step']"/>

    <!-- find all properties that are output in both first and last steps: -->
    <xsl:variable name="properties">
      <xsl:for-each select="$steps[position()=1]/cml:propertyList/cml:property">
        <xsl:variable name="dictRef" select="@dictRef"/>
        <xsl:if test="$steps[position()=last()]/cml:propertyList/cml:property[@dictRef=$dictRef]">
          <xsl:copy-of select="."/>
	</xsl:if>
      </xsl:for-each>
    </xsl:variable>

    <xsl:variable name="allPoints">
      <xsl:call-template name="selectPointsFromNodes">
        <xsl:with-param name="nodes" select="exsl:node-set($steps)"/>
        <xsl:with-param name="propertyNames" select="exsl:node-set($properties)/cml:property/@dictRef"/>
      </xsl:call-template>
    </xsl:variable>
    <!-- for each of said properties ... -->
    <xsl:for-each select="exsl:node-set($properties)/cml:property">
        <xsl:variable name="units" select="cml:scalar/@units"/>
        <!-- lookup units somewhere -->
        <xsl:variable name="dictName">
          <xsl:call-template name="get.dictionary.reference.html">
            <xsl:with-param name="dictRef" select="@dictRef"/>
            <xsl:with-param name="title" select="@title"/>
          </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="graphNodeSet">
          <xsl:call-template name="selectedPointsFromList">
            <xsl:with-param name="pointList" select="exsl:node-set($allPoints)"/>
            <xsl:with-param name="dictRef" select="@dictRef"/>
	  </xsl:call-template>
	</xsl:variable> 
        <!-- draw the graph -->
        <xsl:variable name="graph">
          <xsl:call-template name="drawGraph">
            <xsl:with-param name="graphTitle" select="$dictName"/>
            <xsl:with-param name="xAxisTitle" select="'Step'"/>
            <xsl:with-param name="yAxisTitle" select="$units"/>
            <xsl:with-param name="pointSet" select="exsl:node-set($graphNodeSet)"/>
          </xsl:call-template> 
        </xsl:variable>
        <!-- output the graph -->
        <xsl:variable name="graphId" select="generate-id()"/>
        <tr class="graph">
          <td class="graph"><xsl:value-of select="$dictName"/>:</td>
          <td class="graph"><input type="button" value="Show" onclick="js:toggleButton(this, &quot;{$graphId}&quot;)"/></td><br/>
          <div style="display:none;" id="{$graphId}"><xsl:copy-of select="$graph"/></div>
        </tr>
    </xsl:for-each>
  </table>
  </xsl:template>

</xsl:stylesheet>
  
EOF
cat > $TMPXSLTDIR/table.xsl << "EOF"
<?xml version="1.0" encoding="UTF-8" ?>

<!--===================== TABLE =========================-->

<xsl:stylesheet version="1.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	xmlns:str="http://exslt.org/strings"
        xmlns:cml="http://www.xml-cml.org/schema"
        xmlns="http://www.w3.org/1999/xhtml"
        extension-element-prefixes="str">

  <xsl:template match="cml:table">
    <table>
      <xsl:for-each select="cml:array">
        <xsl:choose>
          <xsl:when test="position() = 1">
	    <tr>
	      <th>Atom</th>
              <xsl:for-each select="str:tokenize(.)">
                <th><xsl:value-of select="."/></th>
	      </xsl:for-each>
	    </tr>
          </xsl:when>
	  <xsl:otherwise>
            <tr>
	      <td><xsl:value-of select="@ref"/></td>
              <xsl:for-each select="str:tokenize(.)">
                <td><xsl:value-of select="format-number(., ' 0.000')"/></td>
	      </xsl:for-each>
	    </tr>
	  </xsl:otherwise>
        </xsl:choose>
      </xsl:for-each>
    </table>
  </xsl:template>

</xsl:stylesheet>
EOF
cat > $TMPXSLTDIR/toby_graph.xsl << "EOF"
<?xml version="1.0" encoding="UTF-8" ?>
<!-- 
     Copyright (c) 2005 Toby White <tow21@cam.ac.uk>

     Permission is hereby granted, free of charge, to any person obtaining 
     a copy of this software and associated documentation files (the 
     "Software"), to deal in the Software without restriction, including 
     without limitation the rights to use, copy, modify, merge, publish, 
     distribute, sublicense, and/or sell copies of the Software, and to 
     permit persons to whom the Software is furnished to do so, subject to 
     the following conditions:

     The above copyright notice and this permission notice shall be 
      included in all copies or substantial portions of the Software.

     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
--> 


<xsl:stylesheet
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        xmlns:exsl="http://exslt.org/common"
        xmlns:math="http://exslt.org/math"
        xmlns:tohw="http://www.uszla.me.uk/xsl/1.0/functions"
        xmlns:g="http://www.uszla.me.uk/xsl/1.0/graph"
        xmlns="http://www.w3.org/2000/svg"
        extension-element-prefixes="exsl math tohw"
        version="1.0">

  <xsl:import href="graphfuncs.xsl"/>

  <!-- Aid to visualizing geometry:

       In SVG coordinates;


       .________________________________________________________.
       |                                                        |
       |                                                        |
       |                                                        |
       |                                                        |
       |                                                        |
       |                                                        |
       |                                                        | 
       |                                                        | 
       |                                                        |
       |                                                        |
       |                                                        |
       |                                                        |
       .________________________________________________________.

-->




  <xsl:template name="drawGraph">

    <xsl:param name="canvasX" select="600"/>
    <xsl:param name="canvasY" select="500"/>

    <xsl:param name="pointSet"/>
    <xsl:param name="paramSet" select="'None'"/>

    <xsl:param name="xAxisTitle" select="default"/>
    <xsl:param name="yAxisTitle" select="default"/>
    <xsl:param name="graphTitle" select="default"/>

    <!-- Convert floating point numbers to Xpath-compliant numbers. -->

    <xsl:variable name="cleanPointSet">
      <xsl:call-template name="launderTree">
        <xsl:with-param name="tree" select="exsl:node-set($pointSet)"/>
      </xsl:call-template>
    </xsl:variable>

    <xsl:call-template name="drawCleanGraph">
      <xsl:with-param name="canvasX" select="$canvasX"/>
      <xsl:with-param name="canvasY" select="$canvasY"/>
      <xsl:with-param name="pointSet" select="exsl:node-set($cleanPointSet)"/>
      <xsl:with-param name="xAxisTitle" select="$xAxisTitle"/>
      <xsl:with-param name="yAxisTitle" select="$yAxisTitle"/>
      <xsl:with-param name="graphTitle" select="$graphTitle"/>
    </xsl:call-template>

  </xsl:template>

  <xsl:template name="drawCleanGraph">

    <!-- Interface to the function; 
	 canvasX:
         canvasY:     size of output graphic in x & y directions.
	              (The size of the actual graph will be smaller, in 
                      order to fit in all the text round the edges.)
	 pointSet:     The data from which the graph will be 
                       generated. The format of pointSet is
                       described in README.
         paramSet:     A set of parameters for the graph. If not
	               supplied, then a (hopefully reasonable)
		       default is calculated below in default-geometry.
		       The format of paramSet is also described in README.
         xAxisTitle: 
         yAxisTitle:   Labels for the x & y axes. These may also be
                       specified in paramSet, but specifying this parameter
                       overrides any paramSet specification.
         graphTitle:   Graph title. This may also be specified in paramSet.                 
                       Again, specifying this parameter overrides any
                       paramSet specification.
   -->
    <!-- Input parameters -->

    <xsl:param name="canvasX" select="600"/>
    <xsl:param name="canvasY" select="500"/>

    <xsl:param name="pointSet"/>
    <xsl:param name="paramSet" select="'None'"/>

    <xsl:param name="xAxisTitle" select="default"/>
    <xsl:param name="yAxisTitle" select="default"/>
    <xsl:param name="graphTitle" select="default"/>

    <!-- Calculate dependent variables -->

    <!-- Work out the min and max X and Y data values 
         Note necessity of number() call to trim whitespace-->
    <xsl:variable name="minX" select="math:min($pointSet/g:pointList/g:point/@x)"/>
    <xsl:variable name="maxX" select="math:max($pointSet/g:pointList/g:point/@x)"/>
    <xsl:variable name="minY" select="math:min($pointSet/g:pointList/g:point/@y)"/>
    <xsl:variable name="maxY" select="math:max($pointSet/g:pointList/g:point/@y)"/>

    <!-- Work out the range of x and y axis values -->
    <xsl:variable name="rangeX" select="$maxX - $minX"/>
    <xsl:variable name="rangeY" select="$maxY - $minY"/>
    <!-- Calculate default graph parameters -->
    <xsl:variable name="gp">
      <xsl:choose>
	<xsl:when test="$paramSet!='None'">
	  <xsl:value-of select="exsl:node-set($paramSet)"/>
	</xsl:when>
	<xsl:otherwise>
	  <xsl:call-template name="g:default-geometry">
	    <xsl:with-param name="xAxisTitle" select="$xAxisTitle"/>
	    <xsl:with-param name="yAxisTitle" select="$yAxisTitle"/>
	    <xsl:with-param name="canvasX" select="$canvasX"/>
	    <xsl:with-param name="canvasY" select="$canvasY"/>
	    <xsl:with-param name="minX" select="$minX"/>
	    <xsl:with-param name="maxX" select="$maxX"/>
	    <xsl:with-param name="minY" select="$minY"/>
	    <xsl:with-param name="maxY" select="$maxY"/>
	  </xsl:call-template>
	</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>

    <!-- Range of graph -->
    <xsl:variable name="floorX"        select="exsl:node-set($gp)/g:range/@floorX"/>
    <xsl:variable name="ceilingX"      select="exsl:node-set($gp)/g:range/@ceilingX"/>
    <xsl:variable name="floorY"        select="exsl:node-set($gp)/g:range/@floorY"/>
    <xsl:variable name="ceilingY"      select="exsl:node-set($gp)/g:range/@ceilingY"/>
    <xsl:variable name="graphRangeX"   select="exsl:node-set($gp)/g:range/@graphRangeX"/>
    <xsl:variable name="graphRangeY"   select="exsl:node-set($gp)/g:range/@graphRangeY"/>

    <!-- Details of axes -->
       
    <!-- Positions of graph feature on canvas -->
    <xsl:variable name="scaleX"       select="exsl:node-set($gp)/g:positions/@scaleX"/>
    <xsl:variable name="scaleY"       select="exsl:node-set($gp)/g:positions/@scaleY"/>
    <xsl:variable name="canvasRangeX" select="exsl:node-set($gp)/g:positions/@canvasRangeX"/>
    <xsl:variable name="canvasRangeY" select="exsl:node-set($gp)/g:positions/@canvasRangeY"/>
    <xsl:variable name="padLeft"      select="exsl:node-set($gp)/g:positions/@padLeft"/>
    <xsl:variable name="padRight"     select="exsl:node-set($gp)/g:positions/@padRight"/>
    <xsl:variable name="padTop"       select="exsl:node-set($gp)/g:positions/@padTop"/>
    <xsl:variable name="padBottom"    select="exsl:node-set($gp)/g:positions/@padBottom"/>

      <svg zoomAndPan="magnify" width="{$canvasX}" height="{$canvasY}">

<!-- css formatting is not used currently, since it is not
     supported by a sufficiently wide range of user agents.
     (most irritatingly, ksvg; but also inkscape)
     This means lots of duplicated formatting in the svg itself.
     Once ksvg2 is available, I intend to reintroduce the css. -->
<!-- 	<defs>
	  <style type="text/css">
	    <xsl:text>
	      <![CDATA[
            	.xAxisLabels {
			text-anchor: middle;
			fill: #000000;
			font-size: 12px;
			font-weight: normal;
	    	}
	    	.yAxisLabels {
			text-anchor: end;
			fill: #000000;
			font-size: 12px;
			font-weight: normal;
		}
	    	.line0 {
			fill: none;
			stroke: #ff0000;
			stroke-width: 1px;
	    	}
	    	.line1 {
			fill: none;
			stroke: #ff0000;
			stroke-width: 1px;
	    	}
	    	.line2 {
			fill: none;
			stroke: #00ff00;
			stroke-width: 1px;
	    	}
	    	.line3 {
			fill: none;
			stroke: #0000ff;
			stroke-width: 1px;
	    	}
	    	.line4 {
			fill: none;
			stroke: #ffff00;
			stroke-width: 1px;
	    	}
	    	.line5 {
			fill: none;
			stroke: #ff00ff;
			stroke-width: 1px;
	    	}
	    	.line6 {
			fill: none;
			stroke: #00ffff;
			stroke-width: 1px;
	    	}
	    	.line7 {
			fill: none;
			stroke: #330000;
			stroke-width: 1px;
	    	}
	    	.line8 {
			fill: none;
			stroke: #003300;
			stroke-width: 1px;
	    	}
	    	.line9 {
			fill: none;
			stroke: #000033;
			stroke-width: 1px;
	    	}
	    	.line10 {
			fill: none;
			stroke: #333300;
			stroke-width: 1px;
	    	}
	    	.background {
			fill: #ff00ff;
			stroke: #000000;
			stroke-width: 1px;
	    	}
	    	.tick {
			stroke: #000000;
			stroke-width: 1px;
	    	}
	    	.axes {
			stroke: #000000;
			stroke-width: 3px;
	    	}
	    	.graphTitle {
			text-anchor: middle;
			fill: #000000;
			font-size: 14px;
			font-weight: bold;
		}
		.axisTitle {
			text-anchor: middle;
			fill: #000000;
			font-size: 12px;
			font-weight: bold;
	    	}
	      ]]>
	    </xsl:text>
	  </style>
	</defs> -->
	
	<!-- Make the graph's title -->
	<text class="graphTitle" x="{$padLeft + ($canvasRangeX div 2) }" y="24" font-szie="24px" font-weight="bold" text-anchor="middle">
	  <xsl:value-of select="$graphTitle"/>
	</text>
	
	<!-- Draw canvas for graph -->
	<rect x="{$padLeft}" y="{$padTop}" width="{$canvasRangeX}" height="{$canvasRangeY}" class="background" fill="#fff0ff"/>

	<!-- Draw the axes and add ticks -->

	<!-- x axes: -->
	<xsl:for-each select="exsl:node-set($gp)/g:axis[@type='x']">
	  <xsl:variable name="xpos1" select="@xAxisPos"/>
	  <xsl:variable name="xpos2" select="@xAxisPos2"/>
	  <xsl:variable name="xpos2b" select="@xAxisPos2b"/>
	  <xsl:variable name="xpos3" select="@xAxisPos3"/>
	  <line stroke="black"  stroke-width="3px" class="axes" x1="{$padLeft}" y1="{$xpos1}" x2="{$padLeft + $canvasRangeX}" y2="{$xpos1}"/>
	  <xsl:for-each select="g:tickList/g:tick">
	    <xsl:variable name="xTickPos" select="$scaleX * (@value - $floorX) + $padLeft"/>
            <text class="xAxisLabels" x="{$xTickPos}" y="{$xpos2b}" text-anchor="middle" font-size="12px" font-weight="normal">
	      <xsl:value-of select="@value"/>
            </text>
            <line stroke="black" stroke-width="1px" class="tick" x1="{$xTickPos}" y1="{$xpos1}" x2="{$xTickPos}" y2="{$xpos2}"/>
	  </xsl:for-each>
	  <text class="axisTitle" x="{$padLeft + $canvasRangeX div 2}" y="{$xpos3}" font-size="12px" font-weight="bold">
	    <xsl:value-of select="@title"/>
	  </text>
	</xsl:for-each>
	<!-- y axis: -->
	<xsl:for-each select="exsl:node-set($gp)/g:axis[@type='y']">
	  <xsl:variable name="ypos1" select="@yAxisPos"/>
	  <xsl:variable name="ypos2" select="@yAxisPos2"/>
	  <xsl:variable name="ypos3" select="@yAxisPos3"/>
	  <line stroke="black"  stroke-width="3px" class="axes" x1="{$ypos1}" y1="{$padTop}" x2="{$ypos1}" y2="{$padTop + $canvasRangeY}"/>
	  <xsl:for-each select="g:tickList/g:tick">
	    <xsl:variable name="yTickPos" select="$scaleY * ($ceilingY - @value) + $padTop"/>
            <text class="xAxisLabels" x="{$ypos2}" y="{$yTickPos}" text-anchor="end" font-size="12px" font-weight="normal">
	      <xsl:value-of select="@value"/>
            </text>
            <line stroke="black" stroke-width="1px" class="tick" x1="{$ypos1}" y1="{$yTickPos}" x2="{$ypos2}" y2="{$yTickPos}"/>
	  </xsl:for-each>
	  <text class="axisTitle" x="0" y="0" font-size="12px" font-weight="bold" transform="translate({$ypos3},{$padTop + $canvasRangeY div 2}) rotate(-90)">
	    <xsl:value-of select="@title"/>
	  </text>
	</xsl:for-each>

	<!-- iterate over all graphs that must be drawn: -->
	<xsl:for-each select="$pointSet/g:pointList">

	  <!-- Draw points on graph -->
          <xsl:for-each select="g:point">
	    <xsl:variable name="xScaled" select="$scaleX * (@x - $floorX) + $padLeft"/>
	    <xsl:variable name="yScaled" select="$scaleY * ($ceilingY - @y) + $padTop"/>
            <circle r="2" cx="{$xScaled}" cy="{$yScaled}"/>
	  </xsl:for-each>
	  
	  <!-- Draw lines between points -->
          <polyline fill="none" stroke="red" stroke-width="1">
            <xsl:attribute name="class">
              <xsl:value-of select="concat('line', 1)"/>
            </xsl:attribute>
            <xsl:attribute name="points">
              <xsl:for-each select="g:point"> 
		<xsl:variable name="xScaled" select="$scaleX * (@x - $floorX) + $padLeft"/>
		<xsl:variable name="yScaled" select="$scaleY * ($ceilingY - @y) + $padTop"/>
		<xsl:value-of select="$xScaled"/>
		<xsl:text>,</xsl:text>
		<xsl:value-of select="$yScaled"/>
		<xsl:text> </xsl:text>
              </xsl:for-each>
          </xsl:attribute>
          </polyline>
	</xsl:for-each>
	
	<!-- Transform coords into the scale of the graph -->
	<g transform="translate({$padLeft},{$canvasY - $padTop}) scale({$scaleX},{-1 * $scaleY}) translate({-1*$floorX},{-1*$floorY})">
	  
	</g>
	
      </svg>
      
  </xsl:template>


  <xsl:template name="g:default-geometry">
    <!-- Calculate necessary variables for plot positions -->
    <xsl:param name="xAxisTitle"/>
    <xsl:param name="yAxisTitle"/>
    <xsl:param name="canvasX"/>
    <xsl:param name="canvasY"/>
    <xsl:param name="minX"/>
    <xsl:param name="maxX"/>
    <xsl:param name="minY"/>
    <xsl:param name="maxY"/>

    <!-- Work out the range of x and y axis values -->
    <xsl:variable name="rangeX" select="$maxX - $minX"/>
    <xsl:variable name="rangeY" select="$maxY - $minY"/>

    <!-- Round the range values to something useable -->
    <xsl:variable name="floorX">
      <xsl:choose>
	<xsl:when test="$rangeX &gt; 0">
	  <xsl:value-of select="floor($minX div tohw:intpow(10,tohw:floorlog10($rangeX)))*tohw:intpow(10,tohw:floorlog10($rangeX))"/>
	</xsl:when>
	<xsl:when test="$minX != 0">
	  <xsl:variable name="fakeMinX" select="0.9 * $minX"/>
	  <xsl:variable name="fakeRangeX" select="0.2 * $minX"/>
	  <xsl:value-of select="floor($fakeMinX div tohw:intpow(10,tohw:floorlog10($fakeRangeX)))*tohw:intpow(10,tohw:floorlog10($fakeRangeX))"/>
	</xsl:when>
	<xsl:otherwise>
	  -1.0
	</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="ceilingX">
      <xsl:choose>
	<xsl:when test="$rangeX &gt; 0">
	  <xsl:value-of select="ceiling($maxX div tohw:intpow(10,tohw:floorlog10($rangeX)))*tohw:intpow(10,tohw:floorlog10($rangeX))"/>
	</xsl:when>
	<xsl:when test="$minX != 0">
	  <xsl:variable name="fakeMaxX" select="1.1 * $minX"/>
	  <xsl:variable name="fakeRangeX" select="0.2 * $minX"/>
	  <xsl:value-of select="ceiling($fakeMaxX div tohw:intpow(10,tohw:floorlog10($fakeRangeX)))*tohw:intpow(10,tohw:floorlog10($fakeRangeX))"/>
	</xsl:when>
	<xsl:otherwise>
	  1.0
	</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="floorY">
      <xsl:choose>
	<xsl:when test="$rangeY &gt; 0">
	  <xsl:value-of select="floor($minY div tohw:intpow(10,tohw:floorlog10($rangeY)))*tohw:intpow(10,tohw:floorlog10($rangeY))"/>
	</xsl:when>
	<xsl:when test="$minY != 0">
	  <xsl:variable name="fakeMinY" select="0.9 * $minY"/>
	  <xsl:variable name="fakeRangeY" select="0.2 * $minY"/>
	  <xsl:value-of select="floor($fakeMinY div tohw:intpow(10,tohw:floorlog10($fakeRangeY)))*tohw:intpow(10,tohw:floorlog10($fakeRangeY))"/>
	</xsl:when>
	<xsl:otherwise>
	  -1.0
	</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="ceilingY">
      <xsl:choose>
	<xsl:when test="$rangeY &gt; 0">
	  <xsl:value-of select="ceiling($maxY div tohw:intpow(10,tohw:floorlog10($rangeY)))*tohw:intpow(10,tohw:floorlog10($rangeY))"/>
	</xsl:when>
	<xsl:when test="$minY != 0">
	  <xsl:variable name="fakeMaxY" select="1.1 * $minY"/>
	  <xsl:variable name="fakeRangeY" select="0.2 * $minY"/>
	  <xsl:value-of select="ceiling($fakeMaxY div tohw:intpow(10,tohw:floorlog10($fakeRangeY)))*tohw:intpow(10,tohw:floorlog10($fakeRangeY))"/>
	</xsl:when>
	<xsl:otherwise>
	  1.0
	</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>

      <!-- Get the range of values covered on the axes -->
    <xsl:variable name="graphRangeX" select="$ceilingX - $floorX"/>
    <xsl:variable name="graphRangeY" select="$ceilingY - $floorY"/>
    
    <!-- Work out axis types -->
    <xsl:variable name="xAxisType">
      <xsl:choose>
	  <xsl:when test="$floorY &gt;= 0">
	    <!-- The data is all positive - draw x axis at the bottom -->
	    <xsl:value-of select="'bottom'"/>
	  </xsl:when>
	  <xsl:when test="$ceilingY &lt;= 0">
	    <!-- the data is all negative - draw the x axis at the top -->
	    <xsl:value-of select="'top'"/>
	  </xsl:when>
	  <xsl:otherwise>
	    <!-- The data crosses the x axis, find the nominal height of y=0 -->
	    <xsl:value-of select="'middle'"/>
	  </xsl:otherwise>
	</xsl:choose>
    </xsl:variable>
    <xsl:variable name="yAxisType">
      <xsl:choose>
	  <xsl:when test="$floorX &gt;= 0">
	    <!-- The data is all positive - draw y axis at the left -->
	    <xsl:value-of select="'left'"/>
	  </xsl:when>
	  <xsl:when test="$ceilingX &lt;= 0">
	    <!-- the data is all negative - draw the y axis at the right -->
	    <xsl:value-of select="'right'"/>
	  </xsl:when>
	  <xsl:otherwise>
	    <!-- The data crosses the x axis, find the nominal height of y=0 -->
	    <xsl:value-of select="'middle'"/>
	  </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>

    <!-- We can now calculate the offsets necessary to fit the ticklabels in: -->

    <xsl:variable name="maxyStringLength">
      <xsl:choose>
	<xsl:when test="string-length($ceilingY) &gt; string-length($floorY)">
	  <xsl:value-of select="string-length($ceilingY)"/>
	</xsl:when>
	<xsl:otherwise>
	  <xsl:value-of select="string-length($floorY)"/>
	</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>

    <!-- Work out the padding of the graph within the canvas -->
    <!-- We assume each character of the yAxis label is 20px wide  - we probably ought to query this -->
    <!-- We also force a minimum padding of 10px -->
    <xsl:variable name="padLeft">
      <xsl:choose>
	<xsl:when test="$yAxisType='left' or $yAxisType='both'">
	  <xsl:value-of select="40 + (10 * $maxyStringLength)"/>
	</xsl:when>
	<xsl:when test="$yAxisType='right' or $yAxisType='middle'">
	  <xsl:value-of select="10"/>
	</xsl:when>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="padRight">
      <xsl:choose>
	<xsl:when test="$yAxisType='left' or $yAxisType='middle'">
	  <xsl:value-of select="10"/>
	</xsl:when>
	<xsl:when test="$yAxisType='right' or $yAxisType='both'">
	  <xsl:value-of select="40 + (20 * $maxyStringLength)"/>
	</xsl:when>
      </xsl:choose>
    </xsl:variable>
    <!-- And we assume (for the moment) a constant y offset -->
    <xsl:variable name="padTop"    select="75"/>
    <xsl:variable name="padBottom" select="75"/>

    <xsl:variable name="canvasRangeX" select="$canvasX - $padLeft - $padRight"/>
    <xsl:variable name="canvasRangeY" select="$canvasY - $padTop - $padBottom"/>

    <!-- Calculate graph scaling -->
    <xsl:variable name="scaleX" select="$canvasRangeX div $graphRangeX"/>
    <xsl:variable name="scaleY" select="$canvasRangeY div $graphRangeY"/>

    <!-- Calculate positions of paddings and axes on global grid-->
    <!-- x axis -->
    <!-- ?AxisPos is the coordinate (in pixel space) where the axis will be drawn.
         ?AxisPos2 is the coordinate where the ticklabel will be drawn -->
    <xsl:variable name="xAxisPos">
      <xsl:choose>
	<xsl:when test="$xAxisType = 'bottom'">
	  <xsl:value-of select="$padTop + $canvasRangeY"/>
	</xsl:when>
	<xsl:when test="$xAxisType = 'top'">
	  <xsl:value-of select="$padTop"/>
	</xsl:when>
	<xsl:when test="$xAxisType = 'middle'">
	  <xsl:value-of select="$padTop + $ceilingY * $scaleY"/>
	</xsl:when>
      </xsl:choose>
    </xsl:variable>
    <!-- where should ticks extend to -->
    <xsl:variable name="xAxisPos2">
      <xsl:choose>
	<xsl:when test="$xAxisType = 'bottom' or $xAxisType = 'middle'">
	  <xsl:value-of select="$xAxisPos + 5"/>
	</xsl:when>
	<xsl:when test="$xAxisType = 'top'">
	  <xsl:value-of select="$xAxisPos - 5"/>
	</xsl:when>
      </xsl:choose>
    </xsl:variable>
    <!-- where should ticklabels be written -->
    <xsl:variable name="xAxisPos2b">
      <xsl:choose>
        <xsl:when test="$xAxisType = 'bottom' or $xAxisType = 'middle'">
          <xsl:value-of select="$xAxisPos2 + 10"/>
        </xsl:when>
        <xsl:when test="$xAxisType = 'top'">
          <xsl:value-of select="$xAxisPos2"/>
        </xsl:when>
      </xsl:choose>
    </xsl:variable>
    <!-- where should we write the axis title -->
    <xsl:variable name="xAxisPos3">
      <xsl:choose>
	<xsl:when test="$xAxisType = 'bottom' or $xAxisType = 'middle'">
	  <xsl:value-of select="$xAxisPos + 30"/>
	</xsl:when>
	<xsl:when test="$xAxisType = 'top'">
	  <xsl:value-of select="$xAxisPos - 20"/>
	</xsl:when>
      </xsl:choose>
    </xsl:variable>
    <!-- y axis -->
    <xsl:variable name="yAxisPos">
      <xsl:choose>
	<xsl:when test="$yAxisType = 'left'">
	  <xsl:value-of select="$padLeft"/>
	</xsl:when>
	<xsl:when test="$yAxisType = 'right'">
	  <xsl:value-of select="$padLeft + $canvasRangeX"/>
	</xsl:when>
	<xsl:when test="$yAxisType = 'middle'">
	  <xsl:value-of select="$padLeft + $floorY * $scaleY"/>
	</xsl:when>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="yAxisPos2">
      <xsl:choose>
	<xsl:when test="$yAxisType = 'left' or $xAxisType = 'middle'">
	  <xsl:value-of select="$yAxisPos - 5"/>
	</xsl:when>
	<xsl:when test="$yAxisType = 'right'">
	  <xsl:value-of select="$yAxisPos + 5"/>
	</xsl:when>
      </xsl:choose>
    </xsl:variable>
    <!-- where should we write the axis title -->
    <xsl:variable name="yAxisPos3">
      <xsl:choose>
	<xsl:when test="$yAxisType = 'left' or $xAxisType = 'middle'">
	  <xsl:value-of select="$yAxisPos - 20 - 10 * string-length($xAxisTitle)"/>
	</xsl:when>
	<xsl:when test="$yAxisType = 'right'">
	  <xsl:value-of select="$yAxisPos + 20"/>
	</xsl:when>
      </xsl:choose>
    </xsl:variable>

    <g:range 
           floorX     ="{$floorX}" 
           ceilingX   ="{$ceilingX}" 
           floorY     ="{$floorY}"
           ceilingY   ="{$ceilingY}"
           graphRangeX="{$graphRangeX}"
           graphRangeY="{$graphRangeY}"
    />
    
    <g:axis 
           type="x"
           title="{$xAxisTitle}"
           xAxisPos   ="{$xAxisPos}"
           xAxisPos2  ="{$xAxisPos2}"
           xAxisPos2b ="{$xAxisPos2b}"
           xAxisPos3  ="{$xAxisPos3}">
      <xsl:call-template name="g:tickValues">
	<xsl:with-param name="minV" select="$floorX"/>
	<xsl:with-param name="maxV" select="$ceilingX"/>
	<xsl:with-param name="numTicks" select="3"/>
      </xsl:call-template>
    </g:axis>
    <g:axis 
           type="y"
           title="{$yAxisTitle}"
           yAxisPos   ="{$yAxisPos}"
           yAxisPos2  ="{$yAxisPos2}"
           yAxisPos3  ="{$yAxisPos3}">
      <xsl:call-template name="g:tickValues">
	<xsl:with-param name="minV" select="$floorY"/>
	<xsl:with-param name="maxV" select="$ceilingY"/>
	<xsl:with-param name="numTicks" select="4"/>
      </xsl:call-template>
    </g:axis>

    <g:positions
      scaleX      ="{$scaleX}"
      scaleY      ="{$scaleY}"
      canvasRangeX="{$canvasRangeX}"
      canvasRangeY="{$canvasRangeY}"
      padLeft     ="{$padLeft}"
      padRight    ="{$padRight}"
      padTop      ="{$padTop}"
      padBottom   ="{$padBottom}"
    />
    
  </xsl:template>
 

</xsl:stylesheet>
EOF
cat > $TMPXSLTDIR/units.xsl << "EOF"
<?xml version="1.0" encoding="UTF-8" ?>

<!--===================== @units =========================-->

<xsl:stylesheet version="1.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        xmlns:cml="http://www.xml-cml.org/schema"
        xmlns="http://www.w3.org/1999/xhtml"
	>

  <xsl:template name="add.units">
    <xsl:choose>
      <xsl:when test="@units">
        <xsl:text> (</xsl:text><i><xsl:value-of select="@units"/></i><xsl:text>)</xsl:text>
      </xsl:when>
      <xsl:when test="child::*/@units">
        <xsl:text> (</xsl:text><i><xsl:value-of select="child::*/@units"/></i><xsl:text>)</xsl:text>
      </xsl:when>
    </xsl:choose>       
  </xsl:template>


  <xsl:template match="@units">
    <xsl:text> (</xsl:text><i><xsl:value-of select="."/></i><xsl:text>)</xsl:text>
  </xsl:template>
  
</xsl:stylesheet>
EOF
cat > $TMPXSLTDIR/dl_polyDict.xml << "EOF"
<?xml version="1.0"?>
<dictionary dictRef="dlpoly" title="DLPOLY dictionary" xmlns="http://www.xml-cml.org/schema/stmml"/>
EOF
cat > $TMPXSLTDIR/siestaDict.xml << "EOF"
<?xml version="1.0"?>
<?xml-stylesheet href="dict2html.xsl" type="text/xsl"?>

<dictionary dictRef="siesta" title="Siesta dictionary" xmlns="http://www.xml-cml.org/schema/stmml">

  <entry id="Eions" term="Eions">
    <annotation>
      <appinfo/>
    </annotation>
    <definition>Energy of the ions: Inter-local-pseudopotential repulsion</definition>
    <description>
      <div class="dictDescription" xmlns="http://www.w3.org/1999/xhtml">
      </div>
    </description>
   <metadataList>
      <metadata name="dc:creator" content="Jon Wakelin"/>
      <metadata name="dc:date" content=""/>
      <metadata name="dc:source" content=""/>
    </metadataList>
  </entry>

  <entry id="Ena" term="Ena">
    <annotation>
      <appinfo/>
    </annotation>
    <definition>Energy of the Neutral Atoms</definition>
    <description>
   </description>
   <metadataList>
      <metadata name="dc:creator" content="Jon Wakelin"/>
      <metadata name="dc:date" content=""/>
      <metadata name="dc:source" content=""/>
    </metadataList>
  </entry>

  <entry id="Ekin" term="Ekin">
    <annotation>
      <appinfo/>
    </annotation>
    <definition>Kinetic energy of the ions</definition>
    <description>
      <div class="dictDescription" xmlns="http://www.w3.org/1999/xhtml">
      </div>
   </description>
   <metadataList>
      <metadata name="dc:creator" content="Jon Wakelin"/>
      <metadata name="dc:date" content=""/>
      <metadata name="dc:source" content=""/>
    </metadataList>
  </entry>

    <entry id="Enl" term="Enl">
    <annotation>
      <appinfo/>
    </annotation>
    <definition>Energy due to the non-local contribution of the pseudopotentials.</definition>
    <description>
      <div class="dictDescription" xmlns="http://www.w3.org/1999/xhtml">
      </div>
   </description>
   <metadataList>
      <metadata name="dc:creator" content="Jon Wakelin"/>
      <metadata name="dc:date" content=""/>
      <metadata name="dc:source" content=""/>
    </metadataList>
  </entry>

  <entry id="Exc" term="Exc">
    <annotation>
      <appinfo/>
    </annotation>
    <definition>Exchange-Correlation Energy</definition>
    <description>
      <div class="dictDescription" xmlns="http://www.w3.org/1999/xhtml">
      </div>
   </description>
   <metadataList>
      <metadata name="dc:creator" content="Jon Wakelin"/>
      <metadata name="dc:date" content=""/>
      <metadata name="dc:source" content=""/>
    </metadataList>
  </entry>

  <entry id="Etot" term="Etot">
    <annotation>
      <appinfo/>
    </annotation>
    <definition>Total energy of the system (Kohn-Sham functional)</definition>
    <description>
      <div class="dictDescription" xmlns="http://www.w3.org/1999/xhtml">
      </div>
   </description>
   <metadataList>
      <metadata name="dc:creator" content="Jon Wakelin"/>
      <metadata name="dc:date" content=""/>
      <metadata name="dc:source" content=""/>
    </metadataList>
  </entry>

  <entry id="Eharrs" term="Eharris">
    <annotation>
      <appinfo/>
    </annotation>
    <definition>Total energy of the system, calculation using the non-self consistent Harris-Foulkes functional</definition>
    <description>
      <div class="dictDescription" xmlns="http://www.w3.org/1999/xhtml">
      </div>
   </description>
   <metadataList>
      <metadata name="dc:creator" content="Jon Wakelin"/>
      <metadata name="dc:date" content=""/>
      <metadata name="dc:source" content=""/>
    </metadataList>
  </entry>

    <entry id="Emad" term="Emad">
    <annotation>
      <appinfo/>
    </annotation>
    <definition>Madelung energy</definition>
    <description>
      <div class="dictDescription" xmlns="http://www.w3.org/1999/xhtml">
      </div>
   </description>
   <metadataList>
      <metadata name="dc:creator" content="Jon Wakelin"/>
      <metadata name="dc:date" content=""/>
      <metadata name="dc:source" content=""/>
    </metadataList>
  </entry>

  <entry id="DEna" term="DEna">
    <annotation>
      <appinfo/>
    </annotation>
    <definition>Non local</definition>
    <description>
      <div class="dictDescription" xmlns="http://www.w3.org/1999/xhtml">
      </div>
   </description>
   <metadataList>
      <metadata name="dc:creator" content="Jon Wakelin"/>
      <metadata name="dc:date" content=""/>
      <metadata name="dc:source" content=""/>
    </metadataList>
  </entry>

  <entry id="DUscf" term="DUscf">
    <annotation>
      <appinfo/>
    </annotation>
    <definition></definition>
    <description>
      <div class="dictDescription" xmlns="http://www.w3.org/1999/xhtml">
      </div>
   </description>
   <metadataList>
      <metadata name="dc:creator" content="Jon Wakelin"/>
      <metadata name="dc:date" content=""/>
      <metadata name="dc:source" content=""/>
    </metadataList>
  </entry>

  <entry id="DUext" term="DUext">
    <annotation>
      <appinfo/>
    </annotation>
    <definition></definition>
    <description>
      <div class="dictDescription" xmlns="http://www.w3.org/1999/xhtml">
      </div>
    </description>
   <metadataList>
      <metadata name="dc:creator" content="Jon Wakelin"/>
      <metadata name="dc:date" content=""/>
      <metadata name="dc:source" content=""/>
    </metadataList>
  </entry>

  <entry id="E_KS" term="E_KS">
    <annotation>
      <appinfo/>
    </annotation>
    <definition>Kohn-Sham total energy</definition>
    <description>
      <div class="dictDescription" xmlns="http://www.w3.org/1999/xhtml">
    W. Kohn and L. J. Sham. <i>Phys. Rev. A</i>, <b>140</b>, (1965), 1133<br />
    P. Hohenberg and W. Kohn. <i>Phys. Rev. B</i>, <b>136</b>, (1964), 864<br />
      </div>
    </description>
   <metadataList>
      <metadata name="dc:creator" content="Jon Wakelin"/>
      <metadata name="dc:date" content=""/>
      <metadata name="dc:source" content=""/>
    </metadataList>
  </entry>

  <entry id="E_KS_egg" term="E_KS_egg">
    <annotation>
      <appinfo/>
    </annotation>
    <definition>Kohn-Sham total energy with correction for 'eggbox' effect</definition>
    <description>
      <div class="dictDescription" xmlns="http://www.w3.org/1999/xhtml">
      The energy given by E<sup>ks</sup> - E<sup>egg</sup>.  
      It is the responsiblity of the user to supply the fourier coefficients for the eggbox effect.  
      The coefficients must be supplied in the fdf file in an fdf block, see the user guide for details. 
      </div>
   </description>
   <metadataList>
      <metadata name="dc:creator" content="Jon Wakelin"/>
      <metadata name="dc:date" content=""/>
      <metadata name="dc:source" content=""/>
    </metadataList>
  </entry>

  <entry id="Ecorrec" term="Ecorrec">
    <annotation>
      <appinfo/>
    </annotation>
    <definition>Energy correction?</definition>
    <description>
      <div class="dictDescription" xmlns="http://www.w3.org/1999/xhtml">
      </div>
   </description>
   <metadataList>
      <metadata name="dc:creator" content="Jon Wakelin"/>
      <metadata name="dc:date" content=""/>
      <metadata name="dc:source" content=""/>
    </metadataList>
  </entry>

  <entry id="FreeE" term="FreeE">
    <annotation>
      <appinfo/>
    </annotation>
    <definition>Free Energy of the system</definition>
    <description>
      <div class="dictDescription" xmlns="http://www.w3.org/1999/xhtml">
      </div>
    </description>
   <metadataList>
      <metadata name="dc:creator" content="Jon Wakelin"/>
      <metadata name="dc:date" content=""/>
      <metadata name="dc:source" content=""/>
    </metadataList>
  </entry>

<entry id="dDmax" term="dDmax">
    <annotation>
      <appinfo/>
    </annotation>
    <definition>Maximum difference in the density matrix</definition>
    <description>
      <div class="dictDescription" xmlns="http://www.w3.org/1999/xhtml">
      <p>The maximum difference in a given element in the density matrix in two consecutive steps.  
         The cut-off tolerance is governed by the value of MD.maxCGtol in the fdf file.</p>
      <p>Maximum value in the difference between elements of the density matrix during the self-consistency iterations.  
         Self-consistency is achieved when this value is smaller than the tolerance specified.</p>
      </div>
   </description>
   <metadataList>
      <metadata name="dc:creator" content="Jon Wakelin"/>
      <metadata name="dc:date" content=""/>
      <metadata name="dc:source" content=""/>
    </metadataList>
  </entry>

<!-- BASIS SET INFO -->
  <entry id="atm_label" term="Atomic label">
    <annotation>
      <appinfo/>
    </annotation>
    <definition>Label for species.</definition>
    <description>
      <div class="dictDescription" xmlns="http://www.w3.org/1999/xhtml">
        SIESTA requires internally a number to tag each species.
      </div>
   </description>
   <metadataList>
      <metadata name="dc:creator" content="Jon Wakelin"/>
      <metadata name="dc:date" content=""/>
      <metadata name="dc:source" content=""/>
    </metadataList>
  </entry>

  <entry id="iz" term="Atomic number">
    <annotation>
      <appinfo/>
    </annotation>
    <definition>Atomic number</definition>
    <description>
      <div class="dictDescription" xmlns="http://www.w3.org/1999/xhtml">
      </div>
   </description>
   <metadataList>
      <metadata name="dc:creator" content="Jon Wakelin"/>
      <metadata name="dc:date" content=""/>
      <metadata name="dc:source" content=""/>
    </metadataList>
  </entry>

  <entry id="smass" term="Atomic mass">
    <annotation>
      <appinfo/>
    </annotation>
    <definition>Mass of species.</definition>
    <description>
      <div class="dictDescription" xmlns="http://www.w3.org/1999/xhtml">
      </div>
   </description>
   <metadataList>
      <metadata name="dc:creator" content="Jon Wakelin"/>
      <metadata name="dc:date" content=""/>
      <metadata name="dc:source" content=""/>
    </metadataList>
  </entry>

  <entry id="charge" term="Charge">
    <annotation>
      <appinfo/>
    </annotation>
    <definition>Charge on the atom.</definition>
    <description>
      <div class="dictDescription" xmlns="http://www.w3.org/1999/xhtml">
        As defined in <tt>%block PAO.Basis</tt>
      </div>
   </description>
   <metadataList>
      <metadata name="dc:creator" content="Jon Wakelin"/>
      <metadata name="dc:date" content=""/>
      <metadata name="dc:source" content=""/>
    </metadataList>
  </entry>

  <entry id="basistype" term="Basis type">
    <annotation>
      <appinfo/>
    </annotation>
    <definition>Type of basis set.</definition>
    <description>
      <div class="dictDescription" xmlns="http://www.w3.org/1999/xhtml">
    <p>
    Defined using <tt>PAO.BasisType</tt> or <tt>%block PAO.Basis</tt>.  
    SIESTA uses finite-ranged pseudo-atomic orbitals [1,2].</p> 
    <p>Acceptable values are split, split Gaussian, nodes, nonodes.
    Default value: split</p>
    <p>1. Sankey and Niklewsky. <i>Phys. Rev. B</i>, <b>40</b>, (1989), 3979</p>
    <p>2. D. Sanchez-Portal, E. Artacho and J. Soler. <i>J. Phys. Chem. Mater. </i>, <b>8</b>, (1996), 3859</p>    
      </div>
   </description>
   <metadataList>
      <metadata name="dc:creator" content="Jon Wakelin"/>
      <metadata name="dc:date" content=""/>
      <metadata name="dc:source" content=""/>
    </metadataList>
  </entry>

  <entry id="l" term="L">
    <annotation>
      <appinfo/>
    </annotation>
    <definition>Quantum angular momentum</definition>
    <description>
      <div class="dictDescription" xmlns="http://www.w3.org/1999/xhtml">
      </div>
    </description>
   <metadataList>
      <metadata name="dc:creator" content="Jon Wakelin"/>
      <metadata name="dc:date" content=""/>
      <metadata name="dc:source" content=""/>
    </metadataList>
  </entry>
  
  <entry id="cnfigmx" term="Config_max">
    <annotation>
      <appinfo/>
    </annotation>
    <definition>Maximum principal quantum number.</definition>
    <description>
      <div class="dictDescription" xmlns="http://www.w3.org/1999/xhtml">
         Array of values, one for each angular momentum, containing, the maximum principal quantum number present for each.
      </div>
    </description>
   <metadataList>
      <metadata name="dc:creator" content="Jon Wakelin"/>
      <metadata name="dc:date" content=""/>
      <metadata name="dc:source" content=""/>
    </metadataList>
  </entry>
  
  <entry id="lambda" term="Lambda">
    <annotation>
      <appinfo/>
    </annotation>
    <definition></definition>
    <description>
      <div class="dictDescription" xmlns="http://www.w3.org/1999/xhtml">
      </div>
    </description>
   <metadataList>
      <metadata name="dc:creator" content="Jon Wakelin"/>
      <metadata name="dc:date" content=""/>
      <metadata name="dc:source" content=""/>
    </metadataList>
  </entry>
  
  <entry id="lmxkb" term="Lambda">
    <annotation>
      <appinfo/>
    </annotation>
    <definition></definition>
    <description>
    </description>
      <div class="dictDescription" xmlns="http://www.w3.org/1999/xhtml">
      </div>
   <metadataList>
      <metadata name="dc:creator" content="Jon Wakelin"/>
      <metadata name="dc:date" content=""/>
      <metadata name="dc:source" content=""/>
    </metadataList>
  </entry>
  
<!-- E Field -->
<entry id="efield" term="Electric field">
    <annotation>
      <appinfo/>
    </annotation>
    <definition></definition>
    <description>
      <div class="dictDescription" xmlns="http://www.w3.org/1999/xhtml">
      </div>
    </description>
   <metadataList>
      <metadata name="dc:creator" content="Jon Wakelin"/>
      <metadata name="dc:date" content=""/>
      <metadata name="dc:source" content=""/>
    </metadataList>
  </entry>

  
<!-- Miguel -->
  <entry id="E_Fermi" term="Fermi energy">
    <annotation>
      <appinfo/>
    </annotation>
    <definition> All the electronic states below this energy are occupied, and all the energy levels above it, are empty.</definition>
    <description>
      <div class="dictDescription" xmlns="http://www.w3.org/1999/xhtml">
      </div>
    </description>
   <metadataList>
      <metadata name="dc:creator" content="J.M. Pruneda"/>
      <metadata name="dc:date" content="30-MAR-2004"/>
      <metadata name="dc:source" content=""/>
    </metadataList>
  </entry>


  <entry id="nkpoints" term="Number k-points">
    <annotation>
      <appinfo/>
    </annotation>
    <definition>Number of k-vectors used to sample the sample the lattice reciprocal space.</definition>
    <description>
      <div class="dictDescription" xmlns="http://www.w3.org/1999/xhtml">
      </div>
    </description>
   <metadataList>
      <metadata name="dc:creator" content="J.M. Pruneda"/>
      <metadata name="dc:date" content="30-MAR-2004"/>
      <metadata name="dc:source" content=""/>
    </metadataList>
  </entry>


  <entry id="lattice" term="Lattice">
    <annotation>
      <appinfo/>
    </annotation>
    <definition>Vectors defining the cell with periodic boundary conditions.</definition>
    <description>
      <div class="dictDescription" xmlns="http://www.w3.org/1999/xhtml">
      </div>
    </description>
   <metadataList>
      <metadata name="dc:creator" content="J.M. Pruneda"/>
      <metadata name="dc:date" content="30-MAR-2004"/>
      <metadata name="dc:source" content=""/>
    </metadataList>
  </entry>


  <entry id="cstress" term="Stress tensor (constrained)">
    <annotation>
      <appinfo/>
    </annotation>
    <definition>Constraints imposed over the lattice by the values of the stresses of the system.</definition>
    <description>
      <div class="dictDescription" xmlns="http://www.w3.org/1999/xhtml">
      </div>
    </description>
   <metadataList>
      <metadata name="dc:creator" content="J.M. Pruneda"/>
      <metadata name="dc:date" content="30-MAR-2004"/>
      <metadata name="dc:source" content=""/>
    </metadataList>
  </entry>
  
  
<!-- Toby White -->
  <entry id="dipol" term="Electric dipole">
    <annotation>
      <appinfo/>
    </annotation>
    <definition>A length-three vector describing the electric dipole of the system. Where there charge 	
		distribution of the system is 
      <mathml xmlns="http://www.w3.org/1998/Math/MathML">
        <mi>q</mi><mo>(</mo><mi>r</mi><mo>)</mo>
      </mathml>
      , then
     <mathml xmlns="http://www.w3.org/1998/Math/MathML">
       <mi>mu</mi><mo>=</mo><mo>int</mo><mo>dd</mo><mi>r</mi><mi>q</mi><mo>(</mo><mi>r</mi><mo>)</mo><mi>r</mi>
     </mathml>
    </definition>
    <description>
      <div class="dictDescription" xmlns="http://www.w3.org/1999/xhtml">
      </div>
    </description>
    <metadataList>
      <metadata name="dc:creator" content="T. White"/>
      <metadata name="dc:date" content="30-MAR-2004"/>
      <metadata name="dc:source" content=""/>
    </metadataList>
  </entry>

  <entry id="forces" term="Atomic forces">
    <annotation>
      <appinfo/>
    </annotation>
    <definition>Forces exerted on each atom.</definition>
    <description>
      <div class="dictDescription" xmlns="http://www.w3.org/1999/xhtml">
         An array of size 3 by (number of atoms), which describes the instantaneous forces acting upon each atom.
      </div>
    </description>
    <metadataList>
      <metadata name="dc:creator" content="T. White"/>
      <metadata name="dc:date" content="30-MAR-2004"/>
      <metadata name="dc:source" content=""/>
    </metadataList>
  </entry>
  
  
  <entry id="stress" term="Stress tensor">
    <annotation>
      <appinfo/>
    </annotation>
    <definition>The stress tensor &#932; of a system is a three by three matrix whose elements 
        	&#932;<sub><i>ij</i></sub> represent the stress on the <i>i</i> plane in the <i>j</i> direction.</definition>
    <description>
      <div class="dictDescription" xmlns="http://www.w3.org/1999/xhtml">
      </div>
    </description>
    <metadataList>
      <metadata name="dc:creator" content="T. White"/>
      <metadata name="dc:date" content="30-MAR-2004"/>
      <metadata name="dc:source" content=""/>
    </metadataList>
  </entry>
  
  
  <entry id="pressSol" term="System pressure">
    <annotation>
      <appinfo/>
    </annotation>
    <definition>The isotropic pressure of the system. Equal to the trace of the stress tensor.</definition>
    <description>
      <div class="dictDescription" xmlns="http://www.w3.org/1999/xhtml">
      </div>
    </description>
    <metadataList>
      <metadata name="dc:creator" content="T. White"/>
      <metadata name="dc:date" content="30-MAR-2004"/>
      <metadata name="dc:source" content=""/>
    </metadataList>
  </entry>
  
  
   <entry id="pressMol" term="Molecular pressure">
    <annotation>
      <appinfo/>
    </annotation>
    <definition>The molecular pressure of the system; equal to the total pressure minus the virial.</definition>
    <description>
      <div class="dictDescription" xmlns="http://www.w3.org/1999/xhtml">
      </div>
    </description>
    <metadataList>
      <metadata name="dc:creator" content="T. White"/>
      <metadata name="dc:date" content="30-MAR-2004"/>
      <metadata name="dc:source" content=""/>
    </metadataList>
  </entry>
</dictionary>
EOF
$XSLTPROC -o "$(basename $1 .xml).xhtml" $TMPXSLTDIR/display.xsl "$1"; rm -rf $TMPXSLTDIR
